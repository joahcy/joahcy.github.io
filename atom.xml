<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joahcy</title>
  <subtitle>天下事有难易乎?为之,则难者亦易矣;不为,则易者亦难矣.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.joahcy.com/"/>
  <updated>2017-11-08T07:36:34.840Z</updated>
  <id>http://www.joahcy.com/</id>
  
  <author>
    <name>Joahcy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ServletLifeCycle</title>
    <link href="http://www.joahcy.com/ServletLifeCycle/"/>
    <id>http://www.joahcy.com/ServletLifeCycle/</id>
    <published>2017-11-08T07:36:34.000Z</published>
    <updated>2017-11-08T07:36:34.840Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库事务的四大特性和隔离级别</title>
    <link href="http://www.joahcy.com/MySQL/ACID_TX-Isolation/"/>
    <id>http://www.joahcy.com/MySQL/ACID_TX-Isolation/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2017-11-08T09:37:33.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h3><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下四个属性，通常简称为事务的ACID属性。  </p>
<ul>
<li>原子性(Atomicity): 事务是一个原子操作单元，其堆数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性(Consistency): 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li>隔离性(Isolation): 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li>
<li>持久性(Durability): 事务一旦被提交，它对于数据的修改是永久性的，即时出现系统故障也能够保持。</li>
</ul>
<h3 id="并发带来的问题"><a href="#并发带来的问题" class="headerlink" title="并发带来的问题"></a>并发带来的问题</h3><p>当多个线程都开启事务操作数据库时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，如果不考虑事务的隔离性，会发生以下几种问题:</p>
<ul>
<li>丢失更新：当多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他十五的存在，就会发生丢失更新问题—最后的更新覆盖了有其他事务所做的更新。</li>
<li>脏读: 事务A读取到了事务B已修改但尚未提交的数据。</li>
<li>不可重复读: 事务A读取到了事务B已经提交的修改数据,不符合隔离性。</li>
<li>幻读: 事务A读取到了事务B提交的新增数据，不符合隔离性。<br><strong>脏读和幻读区别: 脏读是事务B里面修改了数据，幻读是事务B新增了数据</strong></li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>“脏读”、”不可重复读”,”幻读”其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。<br>读数据一致性及允许的并发副作用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">读数据一致性</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交(Read uncommitted)</td>
<td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">读已提交(Read committed)</td>
<td style="text-align:center">语句级别</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">可重复读(Repeatable read)</td>
<td style="text-align:center">事务级别</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">串行化(Serializable)</td>
<td style="text-align:center">最高级别</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>数据库事务级别越高，并发副作用越小，但付出的代价也就越大。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<h3 id="隔离级别的查看与设置"><a href="#隔离级别的查看与设置" class="headerlink" title="隔离级别的查看与设置"></a>隔离级别的查看与设置</h3><p>查看: <code>select @@tx_isolation;</code><br>设置: <code>set  [glogal | session]  transaction isolation level 隔离级别名称;</code>或者<code>set tx_isolation=’隔离级别名称;’</code><br><strong>设置数据库的隔离级别一定要是在开启事务之前！</strong>隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事务的四大特性-ACID&quot;&gt;&lt;a href=&quot;#事务的四大特性-ACID&quot; class=&quot;headerlink&quot; title=&quot;事务的四大特性(ACID)&quot;&gt;&lt;/a&gt;事务的四大特性(ACID)&lt;/h3&gt;&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，事务具有以下四
    
    </summary>
    
      <category term="ACID" scheme="http://www.joahcy.com/categories/ACID/"/>
    
      <category term="事务" scheme="http://www.joahcy.com/categories/ACID/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="ACID" scheme="http://www.joahcy.com/tags/ACID/"/>
    
      <category term="事务" scheme="http://www.joahcy.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Servlet的生命周期</title>
    <link href="http://www.joahcy.com/Java/ServletLifeCycle/"/>
    <id>http://www.joahcy.com/Java/ServletLifeCycle/</id>
    <published>2017-10-07T16:00:00.000Z</published>
    <updated>2017-11-08T08:14:28.348Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet的生命周期分为三个阶段：初始化、响应请求、终止。</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段调用init()方法。init()调用的时机有以下3个：</p>
<ol>
<li>Servlet容器启动时，会自动装载配置了<code>&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</code>节点的servlet，调用其init()方法，并且值越小越先启动。</li>
<li>客户端首次请求Servlet时，调用其init()方法。</li>
<li>Servlet类文件被更新后，重新装载Servlet，调用其init()方法。<br><strong>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次</strong> </li>
</ol>
<h3 id="响应请求阶段"><a href="#响应请求阶段" class="headerlink" title="响应请求阶段"></a>响应请求阶段</h3><p>客户端每请求一次servlet就会调用一次service()方法</p>
<h3 id="终止阶段"><a href="#终止阶段" class="headerlink" title="终止阶段"></a>终止阶段</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用已经装载过的Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Servlet的生命周期分为三个阶段：初始化、响应请求、终止。&lt;/p&gt;
&lt;h3 id=&quot;初始化阶段&quot;&gt;&lt;a href=&quot;#初始化阶段&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段&quot;&gt;&lt;/a&gt;初始化阶段&lt;/h3&gt;&lt;p&gt;初始化阶段调用init()方法。ini
    
    </summary>
    
      <category term="servlet" scheme="http://www.joahcy.com/categories/servlet/"/>
    
    
      <category term="servlet" scheme="http://www.joahcy.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁</title>
    <link href="http://www.joahcy.com/MySQL/mysql%E9%94%81/"/>
    <id>http://www.joahcy.com/MySQL/mysql锁/</id>
    <published>2017-09-29T16:00:00.000Z</published>
    <updated>2017-11-03T08:37:38.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><ul>
<li>共享锁【S锁】：又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li>排他锁【X锁】：又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li>
</ul>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
</li>
<li><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
</li>
</ul>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;共享锁和排它锁&quot;&gt;&lt;a href=&quot;#共享锁和排它锁&quot; class=&quot;headerlink&quot; title=&quot;共享锁和排它锁&quot;&gt;&lt;/a&gt;共享锁和排它锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;共享锁【S锁】：又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其
    
    </summary>
    
      <category term="MySQL" scheme="http://www.joahcy.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.joahcy.com/tags/MySQL/"/>
    
      <category term="锁" scheme="http://www.joahcy.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程池源码分析</title>
    <link href="http://www.joahcy.com/Multithreading/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.joahcy.com/Multithreading/线程池源码分析/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2017-10-31T14:24:22.956Z</updated>
    
    <content type="html"><![CDATA[<p>Java面试中，线程池也算是一个高频的问题，其实就JDK源码来看线程池这一块的实现代码应该算是写的清晰易懂的，通过这篇文章，我们就来盘点一下线程池的知识点。<br><strong>本文基于JDK1.8源码进行分析</strong></p>
<p>首先看下线程池构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">        <span class="comment">//忽略赋值与校验逻辑</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造参数比较多，一个一个说下：</p>
<ul>
<li>corePoolSize线程池中的核心线程数</li>
<li>maximumPoolSize线程池中的最大线程数</li>
<li>keepAliveTime线程池中的线程存活时间（准确来说应该是没有任务执行时的回收时间，后面会分析）</li>
<li>unit时间单位</li>
<li>workQueue来不及执行的任务存放的阻塞队列</li>
<li>threadFactory新建woker线程<strong>（注意不是我们提交的任务）</strong>是进行一些属性设置，比如线程名，优先级等等，有默认实现。</li>
<li>handler 任务拒绝策略，当运行线程数已达到maximumPoolSize，队列也已经装满时会调用该参数拒绝任务，有默认实现。</li>
</ul>
<p>当我们向线程池提交任务时，通常使用execute方法，接下来就先从该方法开始分析。<br>在分析execute代码之前，需要先说明下，我们都知道线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，<strong>线程池维护的这批线程被封装成了Worker。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">//JDK8的源码中，线程池本身的状态跟worker数量使用同一个变量ctl来维护</span></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">//通过位运算得出当然线程池中的worker数量与构造参数corePoolSize进行比较</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="comment">//如果小于corePoolSize，则直接新增一个worker，并把当然用户提交的任务command作为参数，如果成功则返回。</span></div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//如果失败，则获取最新的线程池数据</span></div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果线程池仍在运行，则把任务放到阻塞队列中等待执行。</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">//这里的recheck思路是为了处理并发问题</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//当任务成功放入队列时，如果recheck发现线程池已经不再运行了则从队列中把任务删除</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            <span class="comment">//删除成功以后，会调用构造参数传入的拒绝策略。</span></div><div class="line">            reject(command);</div><div class="line">         <span class="comment">//如果worker的数量为0（此时队列中可能有任务没有执行），则新建一个worker（由于此时新建woker的目的是执行队列中堆积的任务，</span></div><div class="line">         <span class="comment">//因此入参没有执行任务，详细逻辑后面会详细分析addWorker方法）。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果前面的新增woker，放入队列都失败，则会继续新增worker，此时线程池的状态是woker数量达到corePoolSize，阻塞队列任务已满</span></div><div class="line">    <span class="comment">//只能基于maximumPoolSize参数新建woker</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        <span class="comment">//如果基于maximumPoolSize新建woker失败，此时是线程池中线程数已达到上限，队列已满，则调用构造参数中传入的拒绝策略</span></div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码里我增加了很多注释，需要多读几遍才能完全理解，总结一下用户向线程池提交任务以后，线程池的执行逻辑：</p>
<ol>
<li>如果当前woker数量小于corePoolSize，则新建一个woker并把当前任务分配给该woker线程，成功则返回。</li>
<li>如果第一步失败，则尝试把任务放入阻塞队列，如果成功则返回。</li>
<li>如果第二步失败，则判断如果当前woker数量小于maximumPoolSize，则新建一个woker并把当前任务分配给该woker线程，成功则返回。</li>
<li>如果第三步失败，则调用拒绝策略处理该任务。<br>从execute的源码可以看出addWorker方法是重中之重，马上来看下它的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    <span class="comment">//这里有一段基于CAS+死循环实现的关于线程池状态，线程数量的校验与更新逻辑就先忽略了，重点看主流程。</span></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         <span class="comment">//把指定任务作为参数新建一个worker线程</span></div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="comment">//这里是重点，咋一看，一定以为w.thread就是我们传入的firstTask</span></div><div class="line">        <span class="comment">//其实是通过线程池构造函数参数threadFactory生成的woker对象</span></div><div class="line">        <span class="comment">//也就是说这个变量t就是代表woker线程。绝对不是用户提交的线程任务firstTask！！！</span></div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//加锁之后仍旧是判断线程池状态等一些校验逻辑。</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) </div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    <span class="comment">//把新建的woker线程放入集合保存，这里使用的是HashSet</span></div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                <span class="comment">//然后启动woker线程</span></div><div class="line">                <span class="comment">//这里再强调一遍上面说的逻辑，该变量t代表woker线程，也就是会调用woker的run方法</span></div><div class="line">                t.start();</div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            <span class="comment">//如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等等</span></div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>addWorker方法主要做的工作就是新建一个Woker线程，加入到woker集合中，然后启动该线程，那么接下来的重点就是Woker类的run方法了。</p>
<p>worker执行方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Woker类实现了Runnable接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终woker执行逻辑走到了这里</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    <span class="comment">//task就是Woker构造函数入参指定的任务，即用户提交的任务</span></div><div class="line">    Runnable task = w.firstTask;</div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); </div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中</span></div><div class="line">        <span class="comment">//这里getTask方法是要重点说明的，它的实现跟我们构造参数设置存活时间有关</span></div><div class="line">        <span class="comment">//我们都知道构造参数设置的时间代表了线程池中的线程，即woker线程的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。</span></div><div class="line">        <span class="comment">//来不及执行的任务，线程池会放入一个阻塞队列，getTask方法就是去阻塞队列中取任务，用户设置的存活时间，就是</span></div><div class="line">        <span class="comment">//从这个阻塞队列中取任务等待的最大时间，如果getTask返回null，意思就是woker等待了指定时间仍然没有</span></div><div class="line">        <span class="comment">//取到任务，此时就会跳过循环体，进入woker线程的销毁逻辑。</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//该方法是个空的实现，如果有需要用户可以自己继承该类进行实现</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//真正的任务执行逻辑</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">//该方法是个空的实现，如果有需要用户可以自己继承该类进行实现</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">//这里设为null，也就是循环体再执行的时候会调用getTask方法</span></div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">//当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作，比如在corePoolSize跟maximumPoolSize之间的woker会进行回收</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑。<br><strong>注：这里只会回收corePoolSize与maximumPoolSize直接的那部分woker</strong></p>
<p>理解了整个线程池的运行原理以后，再来看下JDK默认提供的线程池类型就会一目了然了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="comment">//corePoolSize跟maximumPoolSize值一样，同时传入一个无界阻塞队列</span></div><div class="line">    <span class="comment">//根据上面分析的woker回收逻辑，该线程池的线程会维持在指定线程数，不会进行回收</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//线程池中只有一个线程进行任务执行，其他的都放入阻塞队列</span></div><div class="line">    <span class="comment">//外面包装的FinalizableDelegatedExecutorService类实现了finalize方法，在JVM垃圾回收的时候会关闭线程池</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//这个线程池corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE，意思也就是说来一个任务就创建一个woker，回收时间是60s</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后再说说初始化线程池时线程数的选择：</p>
<ul>
<li>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</li>
<li>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。<br>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</li>
</ul>
<blockquote>
<p>转载自: <a href="http://www.jianshu.com/p/5df6e38e4362" target="_blank" rel="external">http://www.jianshu.com/p/5df6e38e4362</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java面试中，线程池也算是一个高频的问题，其实就JDK源码来看线程池这一块的实现代码应该算是写的清晰易懂的，通过这篇文章，我们就来盘点一下线程池的知识点。&lt;br&gt;&lt;strong&gt;本文基于JDK1.8源码进行分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先看下线程池构造函数：&lt;b
    
    </summary>
    
      <category term="ThreadPool" scheme="http://www.joahcy.com/categories/ThreadPool/"/>
    
    
      <category term="ThreadPool" scheme="http://www.joahcy.com/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高级知识点总结</title>
    <link href="http://www.joahcy.com/MySQL/mysql_advance/"/>
    <id>http://www.joahcy.com/MySQL/mysql_advance/</id>
    <published>2017-09-23T16:00:00.000Z</published>
    <updated>2017-09-25T04:07:51.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL系统架构介绍"><a href="#MySQL系统架构介绍" class="headerlink" title="MySQL系统架构介绍"></a>MySQL系统架构介绍</h2><h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><h3 id="修改mysql字符集编码"><a href="#修改mysql字符集编码" class="headerlink" title="修改mysql字符集编码"></a>修改mysql字符集编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[clinet]</div><div class="line">default-character-set=utf8</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">character_set_server=utf8</div><div class="line">character_set_client=utf8</div><div class="line">collation-server=utf8_general_ci</div><div class="line"></div><div class="line">[mysql]</div><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure>
<h3 id="MySQL文件"><a href="#MySQL文件" class="headerlink" title="MySQL文件"></a>MySQL文件</h3><ul>
<li>二进制日志log-bin: 用于主从复制</li>
<li>错误日志log-error: 默认关闭的，记录严重的错误和警告信息、每次启动和关闭的详细信息。</li>
<li>查询日志log: 默认关闭，记录查询的sql语句，如果开启会降低mysql的整体性能，因为记录日志也会消耗系统资源。</li>
<li>数据文件：<ol>
<li>主目录: Windows：D:/MySQL_HOME/data; Linux: 默认为 /var/lib/mysql</li>
<li>frm文件: 存放表结构</li>
<li>myd文件: 存放表数据</li>
<li>myi文件: 存放表索引</li>
</ol>
</li>
<li>配置<ol>
<li>windows: my.ini文件</li>
<li>linux: my.cnf文件(默认位置: /usr/my.cnf)<br>扫描顺序: /etc/my.cnf,/etc/mysql/my.cnf,/usr/local/mysql/etc/my.cnf,~/.my.cnf</li>
</ol>
</li>
</ul>
<h3 id="MySQL总体概览"><a href="#MySQL总体概览" class="headerlink" title="MySQL总体概览"></a>MySQL总体概览</h3><p>Mysql和其他数据库相比,MySQl有点与众不同，他的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离</strong>。这种可以根据业务需求和实际需求需要选择合适的存储引擎。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170918/a7FfFi4mC8.jpg?imageslim" alt="MySQL总体架构图"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170918/5Jjg14KfCB.jpg?imageslim" alt="各层作用"></p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><ul>
<li>查看命令: <code>show engines</code> , <code>show variables like &quot;%storage_engine%&quot;</code></li>
<li>主要有InnoDB和MYISAM<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170918/fBLbIcaF58.jpg?imageslim" alt="InnoDB和MYISAM对比"></li>
</ul>
<h2 id="MySQL索引优化分析"><a href="#MySQL索引优化分析" class="headerlink" title="MySQL索引优化分析"></a>MySQL索引优化分析</h2><h3 id="性能下降SQL慢，执行时间长，等待时间长原因"><a href="#性能下降SQL慢，执行时间长，等待时间长原因" class="headerlink" title="性能下降SQL慢，执行时间长，等待时间长原因"></a>性能下降SQL慢，执行时间长，等待时间长原因</h3><ul>
<li>查询语句写的烂</li>
<li>索引失效<ol>
<li>单值—create index idxName on tableName(feild)</li>
<li>复合—create index idxName on tableName(feild1,feild2)</li>
</ol>
</li>
<li>关联查询太多join</li>
<li>服务器调优及各个参数的设置（缓冲、线程数等）</li>
</ul>
<h3 id="常用的通用join查询"><a href="#常用的通用join查询" class="headerlink" title="常用的通用join查询"></a>常用的通用join查询</h3><ul>
<li><p>SQL执行顺序<br>手写:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/meBfALCB4d.jpg?imageslim" alt="手写"><br>机读:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170918/C5l1EE2lKk.jpg?imageslim" alt="机读"><br>总结:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170918/hL8Dcfa0A1.jpg?imageslim" alt="总结"></p>
</li>
<li><p>7种join理论图</p>
<ol>
<li>内连接: <code>select * from tableA A inner join tableB B on A.key=B.key</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/16977mc995.jpg?imageslim" alt="内连接"></li>
<li>左连接: <code>select * from tableA A left join tableB B on A.key=B.key</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/mbmJl1Ff7E.jpg?imageslim" alt="左连接"></li>
<li>左外连接: <code>select * from tableA A left join tableB B on A.key=B.key where B.key is NULL</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/3hHdj1h0aL.jpg?imageslim" alt="左外连接"></li>
<li>右连接: <code>select * from tableA A right join tableB B on A.key=B.key</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/cH8ciLKkeA.jpg?imageslim" alt="右连接"></li>
<li>右外连接: : <code>select * from tableA A right join tableB B on A.key=B.key where A.key is NULL</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/jcIg646ffF.jpg?imageslim" alt="右外连接"></li>
<li>全连接: <strong>Oracle: </strong> <code>select * from tableA A full outer join tableB B on A.key=B.key</code><br><strong>MySQL: </strong> <code>select * from tableA A left join tableB B on A.key=B.key union select * from tableA A right join tableB B on A.key=B.key</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/8hFLG9269A.jpg?imageslim" alt="全连接"></li>
<li>两表的独立数据: <strong>Oracle: </strong> <code>select * from tableA A full outer join tableB B on A.key=B.key where A.key is NULL or B.key is NULL</code><br><strong>MySQL: </strong> <code>select * from tableA A left join tableB B on A.key=B.key where b.key is NULL union select * from tableA A right join tableB B on A.key=B.key where a.key is NULL</code><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/4aHKB5A5E3.jpg?imageslim" alt="两表的独立数据"></li>
</ol>
</li>
</ul>
<h3 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h3><h4 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h4><p>官方定义为索引是数据结构，目的在于提高查询效率，可以类比字典，简单理解为<strong>排好序的快速查找数据结构</strong>。<br>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。<br>我们平常说的索引，一般都是B树(多路查找搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认都使用B+树索引，统称索引。除了B+树这种索引，还有哈希索引。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/l9bbGBE4gI.jpg?imageslim" alt="B树索引"></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>索引也是一张表，保存了主键与索引字段，并指向实体表的数据，所以索引列也占空间。虽然索引提高可产讯速度，同时却会降低更新表的速度。因为更新表时，MySQL不仅要保存数据，还要更新索引信息。<br>索引只是提高效率的一个因素，如果MySQL有大量数据，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<h4 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h4><ul>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：一个索引包含多个列  </li>
</ul>
<p>基本语法：</p>
<ul>
<li>创建: create [unique] index indexName on tableName(columnName);</li>
<li>删除: drop index indexName on tableName;</li>
<li>查看: show index from tableName;</li>
<li>使用alter命令(四中方式添加数据库索引)：<ol>
<li>alter table tableName add primary key(column_list) ;// 添加一个主键，索引值必须唯一，且不能为NULL</li>
<li>alter table tableName add unique indexName (column_list); //创建唯一索引</li>
<li>alter table tableName add index indexName (column_list); //添加普通索引</li>
<li>alter table tableName add fulltext indexName (column_list); //创建全文索引</li>
</ol>
</li>
</ul>
<h4 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h4><p>包括四中：BTree索引、Hash索引、full-text索引、R-Tree索引。<br>BTree的检索原理:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/bli2HA1lJ4.jpg?imageslim" alt="BTree的检索原理"><br>真是的数据存在于叶子节点，非叶子节点不存储真实的数据，只存储指引搜索方向的数据项。<br>如查询29，总共需要三次IO，效率非常高。3层的B+树可以表示上百万的数据，只需要查找3次，性能的提高将是巨大的。</p>
<h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引?"></a>哪些情况需要创建索引?</h4><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>外键关系建立索引</li>
<li>频繁更新的字段不适合建立索引</li>
<li>where条件里用不到的字段不创建索引</li>
<li>单值/复合索引的选择,who?(高并发建议复合索引)</li>
<li>查询中排序的字段，排序字段若通过索引访问将大大提高排序速度</li>
<li>查询中统计或者分组的字段</li>
</ol>
<h4 id="哪些情况不要建立索引"><a href="#哪些情况不要建立索引" class="headerlink" title="哪些情况不要建立索引"></a>哪些情况不要建立索引</h4><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布平均的字段<br>建立索引的选择性？索引的选择性是指索引列中不同值的树木与表中记录数的比。比值越大，建立的索引效率越大。</li>
</ol>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中的收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划。<br>步骤：<br>1.客户端发送一条Query<br>2.命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer<br>3.MySQL Query Optimizer 对整条Query进行优化，处理掉常量表达式的预算，直接换算成常量值。<br>4.对Query中的查询条件进行简化和转化，如去掉无用或显而易见的条件、结构调整等。<br>5.分析Query中的hint信息(如果有)，看显示Hint信息是否完全可以确定该Query的执行计划。<br>6.若没有hint或hint信息不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据query写相应的计算分析<br>7.得出最后传动侧执行计划</p>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在装入内存或从磁盘上读取数据的时候</li>
<li>IO：磁盘I/O瓶颈发生在数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top、free、iostat、vmstat来查看系统的性能状态</li>
</ul>
<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><ul>
<li>是什么(查看执行计划)？<br>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何执行SQL语句的。分析查询语句或表结构是否存在性能瓶颈。</li>
<li>能干嘛？<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
</li>
<li>怎么玩？ explain+SQL语句<br>执行计划包含的信息: <strong>id、type、key、rows、extar重要</strong><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170920/25Fah4je5c.jpg?imageslim" alt="执行计划各字段"></li>
<li><p>各字段解释</p>
<ol>
<li>id<br>select 查询的序列号，包含一组数字，表时执行查询select子句或操作表的顺序。<br>三种情况: <ul>
<li>id相同，执行顺序由上至下<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/4Dmk40l57I.jpg?imageslim" alt="ID顺序1"></li>
<li>id不同，如果是子查询，id的序号会递增，id越大优先级越高，越先被执行<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/ccg1CfKhca.jpg?imageslim" alt="ID顺序2"></li>
<li>id相同不同同时存在，id相同的认为十一组，由上至下执行，所有id中id越大越先执行<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/e98m9cJBmA.jpg?imageslim" alt="ID顺序2"></li>
</ul>
</li>
<li><p>select type<br>有哪些？SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT，查询的类型主要是用于区别普通查询、联合查询、子查询等的复杂语句</p>
<ul>
<li>SIMPLE：简单的select查询，不包含子查询或union</li>
<li>PRIMARY：查询中若包含任何复杂的子部分，最外层被标记为primary</li>
<li>SUBQUERY：在select或where中包含了子查询</li>
<li>DERIVED：在from列表中包含的子查询被标记为DRIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表中。</li>
<li>UNION：若第二个select出现在union之后，则被标记为UNION；若UNION包含在From子句的子查询中，外层select将被标记为drived</li>
<li>UNION RESULT：从UNION表中获取结果的select</li>
</ul>
</li>
<li><p>table<br>显示这一行的数据是关于哪张表的</p>
</li>
<li><p>type<br>显示查询使用了何种访问类型，<strong>从最好到最差依次是: </strong>system、const、eq_ref、ref、range、index、all。一般来说至少达到range级别，最好能达到ref。  </p>
<ul>
<li>system：表只有一行记录(等于系统表)，这是const类型的特例，可以忽略不计。</li>
<li>const: 表时通过一次索引就找到了，const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一盒常量。</li>
<li>eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描。</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li>
<li>range: 只检索给定范围的行，使用一个索引来选择行一般是在where语句中出现了between、&lt;、&gt;、in等的查询，比全表扫描好。</li>
<li>index: full index scan index只遍历索引树，通常比all快，因为索引文件通常比数据文件小(index从索引文件中读取，而all从硬盘读取)</li>
<li>all: full table scan，遍历全表</li>
</ul>
</li>
<li>possible_keys<br>显示可能应用在这张表中的索引，一个或多个。但不一定被查询实际使用。poss</li>
<li>key<br>实际使用的索引，如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中。</li>
<li>key_len: 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，<strong>并非实际使用长度</strong>，即ken_len是根据表定义而得，不是通过表检索出来的。</li>
<li>ref: 显示索引的哪一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/1l81f9dhC8.jpg?imageslim" alt="ref"></li>
<li>rows: 根据表统计信息及索引选用情况，大致估算出找打所需的记录所需要读取的行数。<strong>数值越小越好</strong>。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/Ihj07d48ib.jpg?imageslim" alt="rows"></li>
<li>extra: 包含不适合在其他列显示但十分重要的额外信息。<strong>using filesort(必须优化)、using temporary(必须优化)、using index(nice,效率不错)重要</strong><ul>
<li>Using filesort: 说明MySQL对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL无法利用索引文成的排序操作称作“文件排序”。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/DDKjiJkmcJ.jpg?imageslim" alt="Usingfilesort"></li>
<li>Using temporary: 使用了临时表保存中间结果，MySQL在堆查询结果排序时使用临时表。常见于order by和分组查询group by。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/5hCDjFHD73.jpg?imageslim" alt="UsingTemporary"></li>
<li>Using index: 表示使用了覆盖索引，避免了访问表的数据行，效率不错！<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170921/CIm4AC0G8c.jpg?imageslim" alt="UsingIndex"><br>覆盖索引: 就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说：<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>Using where: 表明使用了where过滤</li>
<li>Using join buffer: 使用了连接缓存</li>
<li>impossible where: where子句的值总是false,不能用来获取任何元组</li>
<li>select tables optimized away: 在没有groupby子句的情况下，对索引的优化 </li>
<li>distinct: 优化distinct操作，在招待第一匹配的元组后即停止找同样值的动作。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>热身<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170923/B30ACgKEeK.jpg?imageslim" alt="1"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170923/b305CLiJ3E.jpg?imageslim" alt="2"></li>
</ul>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h4><ul>
<li>单表<br>优化前:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/ABCbbaidAf.jpg?imageslim" alt="优化前"><br>优化后:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/Fg476eLig1.jpg?imageslim" alt="优化后"><br><strong>range类型查询字段后面的索引失效</strong></li>
<li>两表<br>优化前:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/2ghea9jc46.jpg?imageslim" alt="优化前"><br>优化后:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/kcAbK8a0J5.jpg?imageslim" alt="优化后">  </li>
<li>三表<br>优化前:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/f7BcLFbbmc.jpg?imageslim" alt="优化前"><br>建索引:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/531iCHl82m.jpg?imageslim" alt="建索引"><br>优化后:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/2j9Jcb4ccK.jpg?imageslim" alt="优化后">  </li>
<li>总结:<ul>
<li>尽可能减少join语句中的NestedLoop的循环总次数,”永远用小结果集驱动大的结果集”</li>
<li>优先优化NestedLoop的内层循环</li>
<li>保证join语句中被驱动表的上join条件字段已经被索引</li>
<li>当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置 </li>
</ul>
</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>原因及解决方案加口诀<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/II8gic79FC.jpg?imageslim" alt="原因及解决方案加口诀">  </li>
</ul>
<blockquote>
<p>全值匹配我最爱，最左前缀要遵守；<br>带头大哥不能死，中间兄弟不能断；<br>索引列上少计算，范围之后全失效；<br>LIKE百分写最右，覆盖索引不写星；<br>不等空值还有or，索引失效要少用；<br>VAR引号不可丢，SQL高级也不难！</p>
</blockquote>
<ul>
<li>总结:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170923/Gffh23Gaaf.jpg?imageslim" alt="总结">   </li>
<li>面试题:<br>面试SQL:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/2CCD1mEEBe.jpg?imageslim" alt="1"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/Jj4HegbEaJ.jpg?imageslim" alt="2"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/ag8kL4bD3D.jpg?imageslim" alt="3"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/fDFFk9B2JI.jpg?imageslim" alt="4"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/A70909eJJg.jpg?imageslim" alt="5"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170922/H865EJh14l.jpg?imageslim" alt="6">  </li>
</ul>
<p>总结:<br>定值、范围还是排序，一般OrderBy是给个范围<br>group by基本上都需要排序，会有临时表产生 </p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好</li>
<li>在选择组合索引的时候，尽量选择可以包含当前query的where子句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="永远小表驱动大表-类似嵌套循环"><a href="#永远小表驱动大表-类似嵌套循环" class="headerlink" title="永远小表驱动大表(类似嵌套循环)"></a>永远小表驱动大表(类似嵌套循环)</h4><ul>
<li>查询优化原则<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/eeg72ahAC2.jpg?imageslim" alt="查询优化原则"></li>
<li>exists<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/Jk3a8EA6aK.jpg?imageslim" alt="exists"><br>例子:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/j9ikblcbHI.jpg?imageslim" alt="例子"></li>
</ul>
<h4 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h4><ul>
<li>order by 子句尽量使用Index方式排序，避免使用filesort<ol>
<li>建表:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/67im460k9I.jpg?imageslim" alt="建表"></li>
<li>例子：<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/CH386hf8jB.jpg?imageslim" alt="例子1"><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/b9bid9A9Eb.jpg?imageslim" alt="例子2"></li>
<li>MySQL支持FileSort和index两种排序方式，index效率高，filesort效率低。</li>
<li>Order by会使用index排序的情况：order by语句使用索引最左前列；使用where子句与order by子句组合满足最左前列。</li>
</ol>
</li>
<li>尽可能在索引上完成排序，遵守最佳左前缀，若不在索引列上，filesort有两种排序算法：双路排序和单路排序。MySQL4.1之前使用双路排序。<ul>
<li>双路排序：扫描两次磁盘，最终得到数据。即从磁盘取排序字段，在buffer进行排序，在从磁盘读取其他字段。</li>
<li>单路排序: 从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，这样效率更快，避免了第二次读取数据。</li>
<li>结论及问题：由于单路是后出的，总体而言好过双路，但单路也有问题。<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/g6mGejLge2.jpg?imageslim" alt="单路缺点"></li>
</ul>
</li>
<li>优化策略: 增大sort_buffer_size和max_length_for_sort_data参数设置<br>Why？<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/2GdA8eAk2f.jpg?imageslim" alt="优化策略"></li>
<li>总结:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/5491ce55aF.jpg?imageslim" alt="总结"><h4 id="group-by关键字优化"><a href="#group-by关键字优化" class="headerlink" title="group by关键字优化"></a>group by关键字优化</h4></li>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀。</li>
<li>当无法使用索引列时，增大sort_buffer_size和max_length_for_sort_data参数设置。</li>
<li>where高于having，能写在where限定的条件就不要去having限定了。</li>
</ul>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中相应时间超过阙值的语句，具体指运行时间超过<strong>(大于，而非大于等于)</strong>long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。收集到以后结合explain进行全面分析。</p>
<h4 id="怎么玩？"><a href="#怎么玩？" class="headerlink" title="怎么玩？"></a>怎么玩？</h4><p><strong>默认情况下，MySQL数据库不开启慢查询日志，需要手动设置。</strong>  </p>
<ul>
<li>查看是否开启及如何开启？<br>查看：<code>show variables like &quot;%slow_query_log%&quot;</code><br>开启：<code>set global slow_query_log=1</code> <strong>只对当前数据库生效，MySQL重启后则会失效，要永久生效，需在my.cnf文件中配置</strong></li>
<li>查看和设置阙值：<br>查看：<code>show variables like &quot;%long_query_time%&quot;</code><br>开启：<code>set global long_query_time=3</code></li>
<li>查看有多少条慢查询记录<br><code>show global status like &quot;%slow_queryies%&quot;</code></li>
<li>慢查询日志永久配置<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/CgaDH6D59C.jpg?imageslim" alt="慢查询日志永久配置"></li>
</ul>
<h4 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h4><ul>
<li><p>查看mysqldumpslow的帮助信息</p>
<ul>
<li>s:表示按照何种方式进行排序<ul>
<li>c:访问次数</li>
<li>l:锁定时间</li>
<li>r:返回记录</li>
<li>t:查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间（默认）</li>
</ul>
</li>
<li>t:返回前面的多少条数据</li>
<li>g:后边搭配一个正则匹配模式，大小写不敏感</li>
</ul>
</li>
<li><p>工作常用参考<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/aKH7da6Hek.jpg?imageslim" alt="工作常用参考"></p>
</li>
</ul>
<h3 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h3><p>利用存储过程脚本往数据库插入1000w条数据。</p>
<ol>
<li><p>建表  </p>
<ul>
<li><p>创建部门表:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE dept(</div><div class="line">id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</div><div class="line">deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,</div><div class="line">dname VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,</div><div class="line">loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>创建员工表:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE emp(</div><div class="line">id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</div><div class="line">empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*编号*/</div><div class="line">ename VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,/*名字*/</div><div class="line">job VARCHAR(9) NOT NULL DEFAULT &quot;&quot;,/*工作*/</div><div class="line">mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*上级编号*/</div><div class="line">hiredate DATE NOT NULL,/*入职时间*/</div><div class="line">sal DECIMAL(7,2) NOT NULL,/*薪水*/</div><div class="line">comm DECIMAL(7,2) NOT NULL,/*红利*/</div><div class="line">deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置参数<br>因为开启了慢查询日志和bin_log,创建函数会拨错，所以要设置一个参数: <code>set global log_bin_trust_function_creators=1</code></p>
</li>
<li><p>创建函数，保证每条数据都不同  </p>
<ul>
<li><p>随机生成字符串函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">DELIMITER $$</div><div class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</div><div class="line">BEGIN</div><div class="line"> DECLARE chars_str VARCHAR(100) DEFAULT &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;;</div><div class="line"> DECLARE return_str VARCHAR(255) DEFAULT &apos;&apos;;</div><div class="line"> DECLARE i INT DEFAULT 0;</div><div class="line"> WHILE i &lt; n DO</div><div class="line">  SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</div><div class="line">  SET i = i + 1;</div><div class="line"> END WHILE;</div><div class="line"> RETURN return_str;</div><div class="line">END $$</div></pre></td></tr></table></figure>
</li>
<li><p>随机生成数函数:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DELIMITER $$</div><div class="line">CREATE FUNCTION	rand_num() RETURNS INT(5)</div><div class="line">BEGIN</div><div class="line"> DECLARE i INT DEFAULT 0;</div><div class="line"> SET i = FLOOR(100+RAND()*10);</div><div class="line"> RETURN i;</div><div class="line">END $$</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建存储过程  </p>
<ul>
<li><p>插部门数据存储过程:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">DELIMITER $$</div><div class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))</div><div class="line">BEGIN</div><div class="line">DECLARE i INT DEFAULT 0;</div><div class="line">SET autocommit = 0;</div><div class="line">REPEAT</div><div class="line">SET i = i + 1;</div><div class="line">INSERT INTO dept(deptno,dname,loc) VALUES ((START+1),rand_string(10),rand_string(8));</div><div class="line">UNTIL i = max_num</div><div class="line">END REPEAT;</div><div class="line">COMMIT;</div><div class="line">END $$</div></pre></td></tr></table></figure>
</li>
<li><p>插员工数据存储过程:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">DELIMITER $$</div><div class="line">CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))</div><div class="line">BEGIN</div><div class="line">DECLARE i INT DEFAULT 0;</div><div class="line"># set autocommit=0 把autocommit设置成0</div><div class="line">SET autocommit = 0;</div><div class="line">REPEAT</div><div class="line">	SET i = i + 1;</div><div class="line">	INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES ((START+i),rand_string(6),&apos;SALESMAN&apos;,0001,CURDATE(),2000,400,rand_num());</div><div class="line">UNTIL i= max_num</div><div class="line">END REPEAT;</div><div class="line">COMMIT;</div><div class="line">END $$</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用存储过程  </p>
<ul>
<li>调用部门存储过程:<br><code>CALL insert_dept(100,10);</code>  </li>
<li>调用部门存储过程:<br><code>CALL insert_emp(100001,500000)</code></li>
</ul>
</li>
</ol>
<h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。默认情况下，处于关闭状态，并保存最近15次的运行结果。<br>分析步骤:  </p>
<ol>
<li>是否支持: <code>show variables like &#39;profiling&#39;</code></li>
<li>开启，默认是关闭的: <code>set profiling = on</code> </li>
<li><p>运行SQL  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from emp group by id%10 limit 150000;</div><div class="line">select * from emp group by id%20 order by 5;</div></pre></td></tr></table></figure>
</li>
<li><p>查看结果，show profiles;</p>
</li>
<li>诊断SQL: <code>show profile cpu , block io [其他参数...] for query [Query_ID]</code><br>参数:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/GgkJmgBdl1.jpg?imageslim" alt="参数"></li>
<li>日常开发需要注意的结论(出现以下的情况时必须优化)  </li>
</ol>
<ul>
<li>converting HEAP to MyISAM: 查询结果太大，内存不够用往磁盘上搬了。</li>
<li>creating tmp table: 拷贝数据到临时表，用完再删除。</li>
<li>copying to tmp table on disk: 把内存中临时表复制到磁盘，很危险了。</li>
<li>locked</li>
</ul>
<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p><strong>永远不要在生产环境开启这个功能</strong>  </p>
<ul>
<li><p>永久配置(在my.cnf文件)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 开启</div><div class="line">general_log=1</div><div class="line"># 记录日志文件的路径</div><div class="line">general_log_file=/path/logfile</div><div class="line"># 输出格式</div><div class="line">log_output=FILE</div></pre></td></tr></table></figure>
</li>
<li><p>临时配置  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set global general_log=1;</div><div class="line">set global log_output=&quot;TABLE&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>将会记录到mysql库中的general_log表中，可以用下面命令查看：<br><code>select * from mysql.general_log</code></p>
<h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>定义: 锁是计算计协调多个进程或线程并发访问某一资源的机制。</li>
<li><p>分类:  </p>
<ol>
<li><p>从对数据操作的类型分为读写锁  </p>
<ul>
<li>读锁(共享锁):针对同一份数据，多个读操作可以同时进行而互不影响。</li>
<li>写锁(排它锁): 当前写操作没有完成，它会阻断其他写锁和读锁  </li>
</ul>
</li>
<li><p>从对数据操作的粒度分为表/行锁</p>
</li>
</ol>
</li>
</ul>
<h3 id="三锁"><a href="#三锁" class="headerlink" title="三锁"></a>三锁</h3><h4 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h4><ul>
<li>特点: 偏向MyISAM引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>加解锁: <code>lock table tableName read(write)</code> <code>unlock tables</code></li>
<li><p>表锁分析: </p>
<ul>
<li>查看哪些表被锁了: <code>show open tables;</code></li>
<li>通过检查table_locks_watied(产生表级锁定的次数)和table_locks_immediate(出现表级锁定争用而发生等待的次数)状态变量来分析系统上的表锁定: <code>show status like &#39;table%&#39;;</code></li>
</ul>
</li>
<li><p>结论：读锁会阻塞写，但是不会阻塞读，而写锁则会把读和写都阻塞。<em>MyISAM的读写锁调度是写优先</em></p>
</li>
</ul>
<h4 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁(偏写)"></a>行锁(偏写)</h4><ul>
<li>特点: 偏向InnoDB引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生死锁冲突定位概率最低，并发度最高。与MyISAM最大不同有两点：一是支持事物，二是采用了行级锁。</li>
<li>支持事物<ul>
<li>事务及ACID属性<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/4mfJ9Bk11A.jpg?imageslim" alt="![mark](http://oqwn6kueb.bkt.clouddn.com/blog/170924/4mfJ9Bk11A.jpg?imageslim)">  </li>
<li>并发带来的问题:  <ul>
<li>丢失更新：当多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他十五的存在，就会发生丢失更新问题—最后的更新覆盖了有其他事务所做的更新。</li>
<li>脏读: 事务A读取到了事务B已修改但尚未提交的数据。</li>
<li>不可重复读: 事务A读取到了事务B已经提交的修改数据,不符合隔离性。</li>
<li>幻读: 事务A读取到了事务B提交的新增数据，不符合隔离性。<strong>脏读和幻读区别: 脏读是事务B里面修改了数据，幻读是事务B新增了数据</strong></li>
</ul>
</li>
<li>事务隔离级别<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/170924/LmKaLfHlAA.jpg?imageslim" alt="事务隔离级别"></li>
</ul>
</li>
<li>索引失效会导致行锁变表锁</li>
<li>间隙锁: 当用范围条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件而得已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</li>
<li>如何锁定一行<br><code>select XXX ... for update</code> 锁定某一行后，其他的操作被阻塞，直到锁定行的会话提交commit。</li>
<li>分析行锁定: <code>show status like &#39;innodb_row_lock%&#39;</code><ul>
<li>innodb_row_lock_current_waits: 当前正在等待锁定的数量</li>
<li><strong>innodb_row_lock_time</strong>: 从系统启动到现在锁定总时间长度</li>
<li><strong>innodb_row_lock_time_avg</strong>: 每次等待所花平均时间</li>
<li>innodb_row_lock_time_max: 从系统启动到现在等待时间最长的一次所花的时间</li>
<li><strong>innodb_row_lock_waits</strong>: 系统启动到现在总共等待的次数</li>
</ul>
</li>
</ul>
<h4 id="页锁-了解即可"><a href="#页锁-了解即可" class="headerlink" title="页锁(了解即可)"></a>页锁(了解即可)</h4><p>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><p>slave会从master读取binlog来进行数据同步  </p>
<p>复制过程分三步：<br>1.master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events。<br>2.slave将master的binary log evnets 拷贝到它的中继日志(relay log)。<br>3.slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的。</p>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个slave</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><p>延时</p>
<h3 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h3><h4 id="配置主机-my-cnf文件"><a href="#配置主机-my-cnf文件" class="headerlink" title="配置主机(my.cnf文件)"></a>配置主机(my.cnf文件)</h4><ul>
<li>主服务器唯一ID(必须): sever-id=1</li>
<li>启用二进制日志(必须): log-bin=</li>
<li>启用错误日志(可选) log-err=</li>
<li>根目录(可选): basedir=</li>
<li>临时目录(可选): tmpdir=</li>
<li>数据目录(可选): datadir=</li>
<li>read-only=0(主机读写都可以)</li>
<li>设置不要复制的数据库(可选): binlog-ignore-db=</li>
<li>设置需要复制的数据库(可选): binlog-do-db=</li>
</ul>
<h4 id="配置从机"><a href="#配置从机" class="headerlink" title="配置从机"></a>配置从机</h4><ul>
<li>从服务器唯一ID(必须): server-id=2</li>
<li>启用二进制日志: log-bin=</li>
</ul>
<h4 id="主机从机都关闭防火墙"><a href="#主机从机都关闭防火墙" class="headerlink" title="主机从机都关闭防火墙"></a>主机从机都关闭防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div></pre></td></tr></table></figure>
<h4 id="在主机上建立账户并授权slave"><a href="#在主机上建立账户并授权slave" class="headerlink" title="在主机上建立账户并授权slave"></a>在主机上建立账户并授权slave</h4><ul>
<li>授权: <code>grant replication slave on *.* to &#39;slaveuser&#39;@&#39;192.168.170.252&#39; identified by &#39;123456&#39;</code>  <code>flush privileges</code></li>
<li>查看master的状态: <code>show master status</code>,记录下file和position的值</li>
</ul>
<h4 id="在从机上配置需要复制的主机"><a href="#在从机上配置需要复制的主机" class="headerlink" title="在从机上配置需要复制的主机"></a>在从机上配置需要复制的主机</h4><ul>
<li><p>配置 server-id=2<br>重启mysql后执行  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">change master to master_host=&apos;192.168.170.251&apos;,</div><div class="line">master_user=&apos;slaveuser&apos;,</div><div class="line">master_password=&apos;123456&apos;,</div><div class="line">master_log_file=&apos;mysqlbin.具体数字&apos;,</div><div class="line">master_log_pos=具体值;</div></pre></td></tr></table></figure>
</li>
<li><p>启动从服务器复制功能: <code>start slave</code></p>
</li>
<li>查看状态: <code>show slave status\G</code><br>两个参数都是yes，说明配置成功。<code>slave_io_running=yes,slave_sql_running</code></li>
</ul>
<h4 id="主机建库，建表，插数据。从机复制"><a href="#主机建库，建表，插数据。从机复制" class="headerlink" title="主机建库，建表，插数据。从机复制"></a>主机建库，建表，插数据。从机复制</h4><h4 id="停止从服务器复制功能"><a href="#停止从服务器复制功能" class="headerlink" title="停止从服务器复制功能"></a>停止从服务器复制功能</h4><p><code>stop slave</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL系统架构介绍&quot;&gt;&lt;a href=&quot;#MySQL系统架构介绍&quot; class=&quot;headerlink&quot; title=&quot;MySQL系统架构介绍&quot;&gt;&lt;/a&gt;MySQL系统架构介绍&lt;/h2&gt;&lt;h3 id=&quot;MySQL安装&quot;&gt;&lt;a href=&quot;#MySQL安装&quot; c
    
    </summary>
    
      <category term="MySQL" scheme="http://www.joahcy.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.joahcy.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="http://www.joahcy.com/JVM/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.joahcy.com/JVM/类的加载机制/</id>
    <published>2017-09-19T16:00:00.000Z</published>
    <updated>2017-10-31T14:00:05.315Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从加载到卸载整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载等7个阶段，其中验证、准备、解析统称为连接。如图:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/171031/1fjBh3cDib.jpg?imageslim" alt="类的生命周期"><br>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。 </p>
<ul>
<li>创建类的实例  </li>
<li>访问类的静态变量  </li>
<li>访问类的静态方法  </li>
<li>反射调用  </li>
<li>当初始化一个类时，发现其父类还未初始化，则先触发父类的初始化  </li>
<li>虚拟机启动时，定义了main()方法的那个类先初始化<br>以上情况称为称对一个类进行“主动引用”，除此种之外，均不会触发类的初始化，称为“被动引用”<br>接口的加载过程与类的加载过程稍有不同。接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="被动引用例子"><a href="#被动引用例子" class="headerlink" title="被动引用例子"></a>被动引用例子</h2><ul>
<li>子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化.</li>
<li>通过数组定义来引用类，不会触发类的初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"superclass init"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"subclass init"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(SubClass.value);<span class="comment">// 被动应用1,子类调用父类的静态变量</span></div><div class="line">		SubClass[] sca = <span class="keyword">new</span> SubClass[<span class="number">10</span>];<span class="comment">// 被动引用2,数组定义来引用类</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>程序运行输出    superclass init<br>                            123<br>从上面的输入结果证明了被动引用1与被动引用2</p>
<ul>
<li>访问类的常量，不会初始化类<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"ConstClass init"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(ConstClass.HELLOWORLD);<span class="comment">// 被动引用3,调用类常量</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>程序输出结果 <code>hello world</code><br>从上面的输出结果证明了被动引用3</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>详解加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p> “加载”(Loading)阶段是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：<br>1、通过一个类的全限定名来获取定义此类的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p>
<p>加载阶段即可以使用系统提供的类加载器在完成,也可以由用户自定义的类加载器来完成。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证：文件格式验证、元数据验证、字节码验证和符号引用验证。  </p>
<ul>
<li>文件格式验证: 是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。如验证魔数是否0xCAFEBABE；主、次版本号是否正在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型；指向常量的索引值是否指向不存在的常量或不符合类型的常量等等…该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区中，经过这个阶段的验证后，字节流才会进入内存的方法区中存储，所以后面的三个验证阶段都是基于方法区的存储结构进行的。</li>
<li>元数据验证: 是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。可能包括的验证如：这个类是否有父类；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法…</li>
<li>字节码验证: 主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。应为因为存在“停机问题”，通俗来讲，就是通过程序去校验程序逻辑是无法做到绝对准确的。由于数据校验的高复杂性，在JDK1.6之后给方法体的Code属性加入了名为“StackMapTable”的属性，可以将字节码的推导准变为类型检查从而节省时间。jdk1.6可以通过设置参数关闭优化或在类型校验失败时退回到类型推导，而jdk1.7不允许退回。</li>
<li>符号引用验证: 发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在“解析阶段”中发生。验证符号引用中通过字符串描述的权限定名是否能找到对应的类；在指定类中是否存在符合方法字段的描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问等等…<br>验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的，可以使用-Xverify：none参数来关闭<br>大部分的类验证措施，以缩短虚拟机类加载时间。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br>public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123。<br>public static final int value=123; //编译时将会为value生成ConstantValue属性，准备阶段进行初始化为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p>
<p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<ul>
<li>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的.收集顺序有源文件的程序顺序决定,静态语句块只能访问到它之前的变量,之后的变量只能赋值不能访问.</li>
<li><code>&lt;clinti&gt;()</code>不需要显示调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>已执行完毕，也就意味着父类的静态语句块优先于子类的执行。</li>
<li><code>&lt;clinti&gt;()</code>对于类或接口不是必须的，如果类中没有静态块或赋值语句，就不会产生<code>&lt;clinti&gt;()</code>。</li>
<li>接口也会产生<code>&lt;clinti&gt;()</code>方法。只有当使用父接口的变量时才会初始化父接口，另外接口的实现类初始化时也不会执行接口的<code>&lt;clinti&gt;()</code>方法。</li>
<li><code>&lt;clinti&gt;()</code>是虚拟机保证线程安全的。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个一个独立的类命名空间。通俗来讲就是，比较两个类是否“相等”，只有在这两个类由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，加载他们的类加载器不同，那这两个类必定不相等。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a>类加载器种类</h4><p>从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。<br>从开发者的角度，类加载器可以细分为： </p>
<ul>
<li><p>启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>
</li>
<li><p>标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
</li>
<li><p>应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。</p>
</li>
</ul>
<p>除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。如图：<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/171031/d8487cLj80.jpg?imageslim" alt="双亲委派模型"></p>
<h4 id="双亲委派模型过程"><a href="#双亲委派模型过程" class="headerlink" title="双亲委派模型过程"></a>双亲委派模型过程</h4><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<h4 id="双亲委派模型的系统实现"><a href="#双亲委派模型的系统实现" class="headerlink" title="双亲委派模型的系统实现"></a>双亲委派模型的系统实现</h4><p>在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name,<span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException&#123;</div><div class="line">    <span class="comment">//首先检查请求的类是否已经加载过了</span></div><div class="line">    Class c = findLoadedClass(name);</div><div class="line">    <span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>)&#123;</div><div class="line">                c = parent.loadClass(name,<span class="keyword">false</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                c = findBootstrapClassOrNull(name);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</div><div class="line">            <span class="comment">//若父类抛出异常，说明父类无法完成加载请求</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//父类无法加载时，再调用本身的findClass()方法进行加载</span></div><div class="line">        <span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</div><div class="line">            c = findClass(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(resolve)&#123;</div><div class="line">        resolveClass(c);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现，具体参考《深入理解Java虚拟机》。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
&lt;h2 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="JVM" scheme="http://www.joahcy.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.joahcy.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM--运行时数据区域</title>
    <link href="http://www.joahcy.com/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>http://www.joahcy.com/JVM/JVM运行时数据区/</id>
    <published>2017-09-16T13:45:50.000Z</published>
    <updated>2017-09-17T03:12:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机在执行java程序的过程会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。包括以下几个运行时数据区域：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。如图：<img src="http://oqwn6kueb.bkt.clouddn.com/blog/170917/K9cL337fiE.png?imageslim" alt="Java虚拟机运行时数据区"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>它是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。每条线程都有独立的程序计数器，之间相互不影响。如果执行java方法，计数器记录的是字节码指令的地址；如果执行的是native方法，计数器值为空。它是唯一一个java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame: 是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。<br>在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈的作用类似，区别是虚拟机栈为Java方法服务，而本地方法栈为Native方法服务。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是线程共享的一块内存区域，主要是用来存放对象实例的，几乎所有的对象实例都在这里分配内存。它是垃圾收集器管理的主要区域，因此很对时候也别称作“GC堆”（Garbage Collected Heap）。从内存回收角度来看，由于现在收集器基本采用分代收集算法，所以Java堆可以分为：新生代和老年代，再细致一点可以分为：Eden空间、From Survivor空间、To Survivor空间。从内存分配角度来看，java堆可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。<br>Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，当然也可扩展（通过 -Xmx和-Xms参数控制）。如果在堆中没有内存完成实例分配，并且堆也在无法扩展时，将抛出OutOfMemoryError异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>是堆的一个逻辑部分，大多数时候被称作永久代，同样是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译期编译后的代码等数据。但在jdk1.7以后，已经把放在永久代的字符串常量池移到堆上了。相对而言，垃圾收集在这个区域是比较少出现的，但并非里面的数据就“永久”存在了，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。一般来说，回收效果并不令人满意，尤其是堆类型的卸载，条件相当苛刻。<br>当方法区无法满足内存分配的需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。运行期间也可将新的常量放入运行时常量池。</p>
<p>运行时常量池是把Class文件常量池加载进来，每个类有一个独立的。刚开始运行时常量池里的链接都是符号链接，跟在Class文件里一样；边运行边就会把用到的常量转换成直接链接，例如说要Class A调用Foo.bar()方法，A.class文件里就会有对该方法的Methodref常量，是个符号链接（只有名字没有实体），加载到运行时常量池也还是一样是符号链接，等真的要调用该方法的时候该常量就会被resolve为一个直接链接（直接指向要调用的方法的实体）。</p>
<p>当常量池无法再申请到内存是会抛出OutOfMemoryError异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机在执行java程序的过程会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。包括以下几个运行时数据区域：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。如图：&lt;img src=&quot;http://oqwn6kueb.b
    
    </summary>
    
      <category term="JVM" scheme="http://www.joahcy.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.joahcy.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM对象探秘</title>
    <link href="http://www.joahcy.com/JVM/JVM%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/"/>
    <id>http://www.joahcy.com/JVM/JVM对象探秘/</id>
    <published>2017-09-15T16:00:00.000Z</published>
    <updated>2017-10-30T13:29:43.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p>在语言层面上，创建对象（例如克隆，反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（本文讨论仅限普通java对象，不包括数组和Class对象等）的创建是一个怎样的过程呢？  </p>
<ol>
<li>虚拟机遇到new指令时，首先检查指令的参数是否在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已被加载、解析和初始化过。若有则进入下一步，否则必须执行相应的类加载过程。</li>
<li>在类加载检查通过后，为对象分配内存，内存所需大小在类加载完成后便可确定。</li>
<li>将分配到的内存空间初始化为零值（不包括对象头）。</li>
<li>对对象进行必要的都设置（如对象头信息）————对JVM来说对象创建完成。</li>
<li>执行对象的init方法对字段进行初始化————产生一个真正可以的对象。</li>
</ol>
<h3 id="内存分配原则"><a href="#内存分配原则" class="headerlink" title="内存分配原则"></a>内存分配原则</h3><ul>
<li>内存分配方法<ol>
<li>指针碰撞: 若Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li>空闲列表: 若Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li>
</ol>
</li>
<li>分配原则：选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。Serial、ParNew等带Compact过程的收集器采用指针碰撞；CMS这种基于Mark-Sweep算法的收集器采用空闲列表。</li>
</ul>
<h3 id="保证内存分配线程安全"><a href="#保证内存分配线程安全" class="headerlink" title="保证内存分配线程安全"></a>保证内存分配线程安全</h3><p>对象的创建非常频繁，所以分配内存时改变指针的位置不是线程安全的。</p>
<ul>
<li>解决方案一: 对分配内存的动作进行同步—实际上虚拟机采用的CAS算法保证原子性</li>
<li>解决方案二: 把内存分配的动作划分到不同的空间进行，即每个线程在java堆预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer ,TLAB)。每个线程在自己的TLAB上分配内存，当TLAB用完并分配新的TLAB时，才需要同步锁定。是否使用TLAB，通过-XX:+/-UseTLAB参数来设定。</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象内存布局分为3快区域: 对象头、实例数据、对齐填充。</p>
<h3 id="对象头-主要包括两部分"><a href="#对象头-主要包括两部分" class="headerlink" title="对象头(主要包括两部分)"></a>对象头(主要包括两部分)</h3><ul>
<li>运行时数据(哈希码、GC分代年龄、所状态标志、线程持有的锁、偏向线程ID、偏向时间戳)</li>
<li>类型指针—即对象指向它的类元数据的指针</li>
<li>若是数组，还有一块内存记录数组的长度</li>
</ul>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储代码中所定义的各种类型的字段内容(包括继承父类的)。存储顺序受到虚拟机分配策略参数(FieldsAllocationStyle)和代码中定义顺序的影响。默认策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>并不是必然存在的，仅仅起占位符的作用，HotSpotVM要求对象起始地址必须是8字节的整数倍，所以当实例数据部分没有对齐时，需要通过对齐填充来补全。</p>
<h2 id="对象的的访问定位"><a href="#对象的的访问定位" class="headerlink" title="对象的的访问定位"></a>对象的的访问定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java堆将会划出一块内存作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的地址信息，如图:  <img src="http://oqwn6kueb.bkt.clouddn.com/blog/171030/BagCA3i8m5.jpg?imageslim" alt="句柄访问"><br><strong>优势:存储的是稳定的句柄地址,在对象被移动时只会改变句柄中的实例数据指针,reference本身不需要修改。</strong></p>
<h3 id="直接指针访问-HotSpot使用次方式"><a href="#直接指针访问-HotSpot使用次方式" class="headerlink" title="直接指针访问(HotSpot使用次方式)"></a>直接指针访问(HotSpot使用次方式)</h3><p>reference中存储的直接就是对象地址，如图:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog/171030/C3EfJaLh3l.jpg?imageslim" alt="直接指针访问"><br><strong>优势:访问速度快,节省了一次指针定位的时间开销。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h2&gt;&lt;h3 id=&quot;对象创建过程&quot;&gt;&lt;a href=&quot;#对象创建过程&quot; class=&quot;headerlink&quot; title=&quot;对
    
    </summary>
    
      <category term="JVM" scheme="http://www.joahcy.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.joahcy.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>hexo 多终端同步博客</title>
    <link href="http://www.joahcy.com/BuildBlog/mutil_term_sync/"/>
    <id>http://www.joahcy.com/BuildBlog/mutil_term_sync/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-08-05T03:46:37.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A电脑"><a href="#A电脑" class="headerlink" title="A电脑:"></a>A电脑:</h2><ul>
<li>添加 /.deploy_git, /public 到.gitignore文件末尾,一个一行</li>
<li>初始化本地仓库<br><code>git init</code></li>
<li>将本地仓库与远程仓库对接<br><code>git remote add origin git@github.com:joahcy/joahcy.github.io.git</code></li>
<li>添加所有本地文件到git<br><code>git add .</code><br><strong>注意:如果自己的主题是克隆下来的,先把主题下的.git文件夹和.gitignore文件删除,不然上传不上去</strong></li>
<li>git提交<br><code>git commit -m &quot;提交hexo配置文件&quot;</code></li>
<li>新建分之并切换<br><code>git branch hexo</code><br><code>git checkout hexo</code></li>
<li>push到Github项目的hexo分支上<br><code>git push origin hexo</code></li>
</ul>
<h2 id="B电脑"><a href="#B电脑" class="headerlink" title="B电脑:"></a>B电脑:</h2><ul>
<li>安装好必备环境:git,nodejs,hexo</li>
<li>将hexo分支克隆岛本地:<br><code>git clone -b git@github.com:joahcy/joahcy.github.io.git joahcyBlog</code></li>
<li>安装依赖<br><code>npm install</code></li>
</ul>
<h2 id="环境装好就可以开心的多端同步更新博客了"><a href="#环境装好就可以开心的多端同步更新博客了" class="headerlink" title="环境装好就可以开心的多端同步更新博客了"></a>环境装好就可以开心的多端同步更新博客了</h2><ul>
<li>先从远程仓库pull<br><code>git pull git@github.com:joahcy/joahcy.github.io.git hexo</code></li>
<li>写博客<br><code>hexo n &quot;test多端同步&quot;</code></li>
<li>利用Markdown编辑器编辑</li>
<li>添加source文件夹到本地git,因为只更改了source文件夹<br><code>git add source</code></li>
<li>提交<br><code>git commit -m &quot;添加多终端同步更新博客&quot;</code></li>
<li>push到远程仓库hexo分支<br><code>git push origin hexo</code></li>
<li>部署<br><code>hexo g -d</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A电脑&quot;&gt;&lt;a href=&quot;#A电脑&quot; class=&quot;headerlink&quot; title=&quot;A电脑:&quot;&gt;&lt;/a&gt;A电脑:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;添加 /.deploy_git, /public 到.gitignore文件末尾,一个一行&lt;/li&gt;
&lt;li&gt;初始化
    
    </summary>
    
      <category term="博客折腾" scheme="http://www.joahcy.com/categories/Buildblog/"/>
    
    
      <category term="Hexo" scheme="http://www.joahcy.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>一个人的生活</title>
    <link href="http://www.joahcy.com/Life/one_person_life/"/>
    <id>http://www.joahcy.com/Life/one_person_life/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-08-05T03:47:23.760Z</updated>
    
    <content type="html"><![CDATA[<center>一个人刷牙··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely1.jpg" alt="一个人刷牙"></center><br><center>一个人吃早点··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely2.jpg" alt="一个人吃早点"></center><br><center>一个人发呆··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely3.jpg" alt="一个人发呆"></center><br><center>一个人玩手机··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely4.jpg" alt="一个人玩手机"></center><br><center>一个人看电视··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely5.jpg" alt="一个人看电视"></center><br><center>一个人睡觉··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely6.jpg" alt="一个人睡觉"></center><br><center>慢慢的习惯了一个人··</center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely7.jpg" alt="习惯了一个人"></center>


<center>有时一个人也挺好，一个人念着一个人，淡淡的是种享受。自由但不自在？享受这种生活至少不会大起大落，喜欢这种表达方式，喜怒哀乐一个人默默的品味…</center>

<center>有时候，莫名的心情不好，不想和任何人说话，只想一个人静静的发呆。</center>

<center>有时候，突然觉得心情烦躁，看什么都觉得不舒服，心里闷的发慌，拼命想寻找一个出口。</center>

<center>有时候，发现身边的人都不了解自己，面对着身边的人，突然觉得说不出话。</center>

<center>有时候，感觉自己与世界格格不入，曾经一直坚持的东西一夜间面目全非。</center>

<center>有时候，突然很想逃离现在的生活，想不顾一切收拾自己简单的行李去流浪。</center>

<center>有时候，别人突然对你说，我觉得你变了，然后自己开始百感交集。</center>

<center>有时候，希望时间为自己停下，就这样和喜欢的人地老天荒。</center>

<center>有时候，在自己脆弱的时候，想一个人躲起来，不愿别人看到自己的伤口。</center>

<center>有时候，突然很想哭，却难过的哭不出来。</center>

<center>有时候，夜深人静的时候，突然觉得寂寞深入骨髓。</center>

<center>有时候，走过熟悉的街角，看到熟悉的背影，突然就想起一个人的脸。</center>

<center>有时候，明明自己心里有很多话要说，却不知道怎样表达。</center>

<center>有时候，觉得自己其实一无所有，仿佛被世界抛弃。</center>

<center>真的只是有时候，明明自己身边很多朋友，却依然觉得孤单。</center>

<center>有时候，很想放纵自己，希望自己彻彻底底醉一次 。</center>

<center>有时候，自己的梦想很多，却力不从心。</center>

<center>有时候，常常找不到事情，无聊的无所适从。</center>

<center>有时候，突然找不到自己，把自己丢了。</center>

<center>有时候，心里突然冒出一种厌倦的情绪，觉得自己很累很累。</center>

<center>有时候，看不到自己未来的样子，迷茫的不知所措。</center>

<center>有时候，发现自己一夜之间长大了。</center>

<center>有时候，听到一首老歌，就突然想起一个人。</center>

<center>有时候，希望能找个人好好疼爱自己，渴望一种安全感。</center>

<center>有时候，别人误解了自己有口无心的一句话，心里郁闷的发慌。</center>

<center>有时候，常常在回忆里挣扎，有很多过去无法释怀。</center>

<center>有时候，渴望一场轰轰烈烈的恋爱，很想去做一些疯狂的事。</center>

<center>有时候，渴望别人的关怀，渴望一份简单的快乐。</center>

<center>有时候，看着时间一点点流逝，自己却无能为力。</center>

<center>其实，真的只是有时候一个人会想这么多。。。 </center><br><center><img src="http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely8.jpg" alt="我的未来?"></center>

<blockquote>
<p>转载 <a href="http://www.blogjava.net/sxyx2008/archive/2010/08/14/328822.html" target="_blank" rel="external">原文链接</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;center&gt;一个人刷牙··&lt;/center&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://oqwn6kueb.bkt.clouddn.com/image/lonely/lonely1.jpg&quot; alt=&quot;一个人刷牙&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;一个
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.joahcy.com/categories/Life/"/>
    
    
      <category term="一个人" scheme="http://www.joahcy.com/tags/%E4%B8%80%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="成长" scheme="http://www.joahcy.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>spark集群安装</title>
    <link href="http://www.joahcy.com/Bigdata/spark-cluster/"/>
    <id>http://www.joahcy.com/Bigdata/spark-cluster/</id>
    <published>2017-07-21T16:00:00.000Z</published>
    <updated>2017-08-14T17:06:14.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>scala2.11.5</li>
<li>java1.8(scala这个版本要求java1.8,所以我把之前的java1.7换成1.8了,<a href="http://pan.baidu.com/s/1mimPhaC" target="_blank" rel="external">1.8下载地址</a>) </li>
<li>spark2.1.0</li>
</ul>
<h2 id="安装Scala"><a href="#安装Scala" class="headerlink" title="安装Scala"></a>安装Scala</h2><ul>
<li>确认已经装好了jdk<br><code>java -version</code></li>
<li><a href="http://pan.baidu.com/s/1kVmRoqV" target="_blank" rel="external">下载地址</a></li>
<li>解压并移动到/usr/local/scala</li>
<li>配置环境变量</li>
</ul>
<h2 id="安装spark"><a href="#安装spark" class="headerlink" title="安装spark"></a>安装spark</h2><h3 id="确认已经装好hadoop"><a href="#确认已经装好hadoop" class="headerlink" title="确认已经装好hadoop"></a>确认已经装好hadoop</h3><p><code>hadoop version</code></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="http://pan.baidu.com/s/1pKB5tpD" target="_blank" rel="external">下载地址</a></p>
<h3 id="解压配置环境变量"><a href="#解压配置环境变量" class="headerlink" title="解压配置环境变量"></a>解压配置环境变量</h3><p>解压并移动到/usr/local/spark<br>然后配置环境变量</p>
<h3 id="到这我们可以简单使用spark"><a href="#到这我们可以简单使用spark" class="headerlink" title="到这我们可以简单使用spark"></a>到这我们可以简单使用spark</h3><p>在<code>$SPARK_HOME/examples/src/main</code>目录下有一些 Spark 的示例程序,有 Scala,Java,Python,R 等语言的版本.我们可以先运行一个示例程序 SparkPi(即计算 π 的近似值),执行如下命令:<br><code>run-example SparkPi</code><br>然后就可以看到结果.</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li>复制spark-env.sh.template成spark-env.sh</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</div><div class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</div><div class="line">SPARK_LOCAL_IP=192.168.170.170</div><div class="line">SPARK_MASTER_HOST=master</div><div class="line">SPARK_WORKER_CORES=2</div><div class="line">SPARK_WORKER_INSTANCES=1</div><div class="line">SPARK_WORKER_DIR=/usr/local/spark/work</div></pre></td></tr></table></figure>
<ul>
<li>复制slaves.template成slaves</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">master</div><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<h3 id="将配置好的spark文件复制到Slave1和Slave2节点。"><a href="#将配置好的spark文件复制到Slave1和Slave2节点。" class="headerlink" title="将配置好的spark文件复制到Slave1和Slave2节点。"></a>将配置好的spark文件复制到Slave1和Slave2节点。</h3><p><code>scp /usr/local/spark slave1:/usr/local</code><br><code>scp /usr/local/spark slave2:/usr/local</code><br>修改Slave1和Slave2配置<br>在Slave1和Slave2上分别配置Spark的环境变量.<br>在Slave1和Slave2修改spark-env.sh,将SPARK_LOCALIP改成Slave1和Slave2对应节点的IP.</p>
<h3 id="在Master节点启动集群"><a href="#在Master节点启动集群" class="headerlink" title="在Master节点启动集群"></a>在Master节点启动集群</h3><p><code>$SPARK_HOME/sbin/start-all.sh</code></p>
<h3 id="用jps命令查看集群是否启动成功"><a href="#用jps命令查看集群是否启动成功" class="headerlink" title="用jps命令查看集群是否启动成功"></a>用jps命令查看集群是否启动成功</h3><ul>
<li>Master在Hadoop的基础上新增了: Master</li>
<li>Slave在Hadoop的基础上新增了: Worker</li>
</ul>
<h3 id="在浏览器上查看"><a href="#在浏览器上查看" class="headerlink" title="在浏览器上查看"></a>在浏览器上查看</h3><p><code>http://master:8080</code><br>看到下图说明安装成功<br><img src="http://oqwn6kueb.bkt.clouddn.com//blog/spark-cluster.jpg" alt="spark-cluster"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;scala2.11.5&lt;/li&gt;
&lt;li&gt;java1.8(scala这个版本要求java1.8,所以我把之前的java1.7换成
    
    </summary>
    
      <category term="Bigdata" scheme="http://www.joahcy.com/categories/Bigdata/"/>
    
    
      <category term="bigdata" scheme="http://www.joahcy.com/tags/bigdata/"/>
    
      <category term="spark" scheme="http://www.joahcy.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>hadoop之hive安装</title>
    <link href="http://www.joahcy.com/Bigdata/hive-install/"/>
    <id>http://www.joahcy.com/Bigdata/hive-install/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-08-14T17:08:02.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>CentOS6.8</li>
<li>java1.8</li>
<li>hadoop2.7.2</li>
<li>mysql5.6.37</li>
<li>hive2.1.1</li>
</ul>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ul>
<li><a href="">mysql5.6.37rpm下载地址</a></li>
<li>安装  <ol>
<li>安装依赖包: <code>rpm -ivh MySQL-devel-5.6.37-1.el6.x86_64.rpm</code></li>
<li>安装服务端: <code>rpm -ivh MySQL-server-5.6.37-1.el6.x86_64.rpm</code>  </li>
<li>安装客户端: <code>rpm -ivh MySQL-client-5.6.37-1.el6.x86_64.rpm</code></li>
</ol>
</li>
<li>开启服务: <code>service mysql start</code></li>
<li>获取登录密码<br>mysql装好后会创建一个默认密码文件在root用户目录下: <code>cat .mysql_secret</code></li>
<li>登录: <code>mysql -uroot -p</code></li>
<li>创建hive用户并授权,允许远程登录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE USER &apos;hive&apos; IDENTIFIED BY &apos;123456&apos;;</div><div class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;hive&apos;@&apos;%&apos; IDENTIFIED BY &apos;hive&apos; WITH GRANT OPTION;</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
<ul>
<li>创建hive数据库<br><code>create database hive;</code></li>
</ul>
<h2 id="hive安装及配置"><a href="#hive安装及配置" class="headerlink" title="hive安装及配置"></a>hive安装及配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ul>
<li><a href="http://pan.baidu.com/s/1dFndtKl" target="_blank" rel="external">下载地址</a></li>
<li>解压后移动到/usr/local/下</li>
<li>配置环境变量</li>
</ul>
<h3 id="配置hive-env-sh"><a href="#配置hive-env-sh" class="headerlink" title="配置hive-env.sh"></a>配置hive-env.sh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HADOOP_HOME=/usr/local/hadoop</div><div class="line">export HIVE_CONF_DIR=/usr/local/hive/conf</div><div class="line">export HIVE_AUX_JARS_PATH=/usr/local/hive/lib</div></pre></td></tr></table></figure>
<h3 id="修改hive-site-xml"><a href="#修改hive-site-xml" class="headerlink" title="修改hive-site.xml"></a>修改hive-site.xml</h3><p>复制一份hive-default.xml.template为hive-site.xml,内容为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</div><div class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</div><div class="line">		&lt;value&gt;jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</div><div class="line">		&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</div><div class="line">		&lt;value&gt;hive&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</div><div class="line">		&lt;value&gt;123456&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/user/hive/warehouse&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.exec.scratchdir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/tmp/hive&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;system:java.io.tmpdir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/usr/local/hive/iotmp&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/usr/local/hive/iotmp/$&#123;user.name&#125;&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/usr/local/hive/iotmp/$&#123;hive.session.id&#125;_resources&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt;</div><div class="line">		&lt;value&gt;/usr/local/hive/iotmp/$&#123;system:user.name&#125;/operation_logs&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hive.querylog.location&lt;/name&gt;</div><div class="line">		&lt;value&gt;/usr/local/hive/iotmp/$&#123;system:user.name&#125;&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h3 id="在本地新建目录"><a href="#在本地新建目录" class="headerlink" title="在本地新建目录"></a>在本地新建目录</h3><p><code>mkdir /usr/local/hive/iotmp</code></p>
<h3 id="在hdfs新建目录并授权"><a href="#在hdfs新建目录并授权" class="headerlink" title="在hdfs新建目录并授权"></a>在hdfs新建目录并授权</h3><p><code>hdfs dfs -mkdir -p /user/hive/warehouse</code><br><code>hdfs dfs -mkdir -p /tmp/hive</code><br><code>hdfs dfs -chmod -R 777 /user/hive/warehouse</code><br><code>hdfs dfs -chmod -R 777 /tmp/hive</code></p>
<h3 id="下载JDBC数据库驱动到-usr-local-hive-lib目录下"><a href="#下载JDBC数据库驱动到-usr-local-hive-lib目录下" class="headerlink" title="下载JDBC数据库驱动到/usr/local/hive/lib目录下"></a>下载JDBC数据库驱动到<code>/usr/local/hive/lib</code>目录下</h3><h3 id="配置子节点"><a href="#配置子节点" class="headerlink" title="配置子节点"></a>配置子节点</h3><p>将Hive分别到slave1,slave2上,并配置hive环境变量<br><code>scp -r /usr/local/hive slave1:/usr/local/</code><br><code>scp -r /usr/local/hive slave2:/usr/local/</code></p>
<h2 id="hive启动及测试"><a href="#hive启动及测试" class="headerlink" title="hive启动及测试"></a>hive启动及测试</h2><h3 id="hive初始化"><a href="#hive初始化" class="headerlink" title="hive初始化"></a>hive初始化</h3><p><code>schematool -initSchema -dbType mysql</code></p>
<h3 id="Hive启动"><a href="#Hive启动" class="headerlink" title="Hive启动"></a>Hive启动</h3><p><code>nohup hive --service metastore &gt;/dev/null 2&gt;&amp;1 &amp;</code>  ##启动远程模式,否则只能在本地登录<br><code>hive</code>  ##客户端登陆</p>
<h3 id="子节点访问"><a href="#子节点访问" class="headerlink" title="子节点访问"></a>子节点访问</h3><p><code>hive</code></p>
<h3 id="基本命令操作-和mysql差不多"><a href="#基本命令操作-和mysql差不多" class="headerlink" title="基本命令操作(和mysql差不多)"></a>基本命令操作(和mysql差不多)</h3><ol>
<li>先创建一个测试库: <code>create database test;</code></li>
<li>创建student表,并指定字段分隔符为tab键(否则会插入NULL)<br><code>create table student(id int,name string) row format delimited fields terminated by &#39;\t&#39;;</code></li>
<li>查看下表结构: <code>describe student;</code></li>
<li><p>创建数据文件,键值要以tab键空格:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat student.txt </div><div class="line">1	zhangsan</div><div class="line">2	lisi</div><div class="line">3	wangwu</div></pre></td></tr></table></figure>
</li>
<li><p>从本地文件中导入数据到Hive表<br><code>load data local inpath &#39;/root/student.txt&#39; overwrite into table student;</code></p>
</li>
<li>从HDFS中导入数据到Hive表<br><code>load data inpath &#39;/student.txt&#39; overwrite into table student;</code></li>
<li>查询是否导入成功<br><code>select * from student;</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CentOS6.8&lt;/li&gt;
&lt;li&gt;java1.8&lt;/li&gt;
&lt;li&gt;hadoop2.7.2&lt;/li&gt;
&lt;li&gt;mysql5.
    
    </summary>
    
      <category term="Bigdata" scheme="http://www.joahcy.com/categories/Bigdata/"/>
    
    
      <category term="hive" scheme="http://www.joahcy.com/tags/hive/"/>
    
      <category term="bigdata" scheme="http://www.joahcy.com/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>hadoop2.7.2集群搭建</title>
    <link href="http://www.joahcy.com/Bigdata/hadoop2.7.2-cluster/"/>
    <id>http://www.joahcy.com/Bigdata/hadoop2.7.2-cluster/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-08-14T09:43:54.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建hadoo集群是学习大数据不可或缺的一步,然而自己练习又没有那么多台主机,只能在虚拟机上搭建了,自己也是第一次搭建,所以在这进行一些必要步骤的记录,下面开始吧.<br><strong>官网下载软件很慢,所以下面提供的都是我的百度云盘下载地址</strong></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>CentOS6.8</li>
<li>java1.7</li>
<li>hadoop2.7.2</li>
</ul>
<h2 id="安装vmware"><a href="#安装vmware" class="headerlink" title="安装vmware"></a>安装vmware</h2><p><a href="http://pan.baidu.com/s/1nvgb2bv" target="_blank" rel="external">vmware10.0下载地址</a>,然后就是傻瓜式安装,这里就不详细说了.</p>
<h2 id="安装linux-我用的是CentOS6-8"><a href="#安装linux-我用的是CentOS6-8" class="headerlink" title="安装linux(我用的是CentOS6.8)"></a>安装linux(我用的是CentOS6.8)</h2><p><a href="http://pan.baidu.com/s/1o7TimL0" target="_blank" rel="external">CentOS6.8下载地址</a>, 如果自己不需要设置分区的话,基本就是下一步下一步完成安装.具体google,百度也有很多教程.<br>安装完成后对网络进行设置,使用nat模式,点击安装好的虚拟机,右键设置,选择网络适配器,然后选择nat模式.启动虚拟机进行登录.<br>查看IP并验证是否能上网,分别执行以下操作:<br><code>ifconfig</code>  eth0 那块网卡的addr就是nat模式下的ip<br><code>ping www.baidu.com</code>  虽然百度害人不浅,但在验证网络上还是有一点用处的,哈哈~~~<br>系统默认DHCP动态分配IP,当系统每次重启,IP可能会变,所以我们要手动设置静态ip.<br>编辑网卡文件:<br><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code><br>我的设置如下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DEVICE=eth0  ## 网卡名</div><div class="line">TYPE=Ethernet</div><div class="line">ONBOOT=yes  ## 设置为开机启动</div><div class="line">BOOTPROTO=static</div><div class="line">HWADDR=00:0C:29:65:9C:41 </div><div class="line">IPADDR=192.168.170.170  ## NAT模式下静态IP</div><div class="line">PREFIX=24  ## 和子网掩码对应</div><div class="line">GATEWAY=192.168.170.2  ## 网关</div><div class="line">DNS1=192.168.170.2  ## DNS</div></pre></td></tr></table></figure>
<p>设置完成后重启网络:<br><code>service network restart</code><br>然后查看IP,并ping一下百度验证是否能上网.若不行,仔细查看配置信息是否正确.</p>
<h2 id="添加hadoop用户"><a href="#添加hadoop用户" class="headerlink" title="添加hadoop用户"></a>添加hadoop用户</h2><ol>
<li><code>user add hadoop</code></li>
<li><code>passwd hadoop</code></li>
<li>登录: <code>su hadoop</code></li>
</ol>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>hadoop的运行依赖java所以得先安装JDK.</p>
<h3 id="卸载OpenJDK"><a href="#卸载OpenJDK" class="headerlink" title="卸载OpenJDK"></a>卸载OpenJDK</h3><p>CentOS6.8自带OpenJDK,安装之前先卸载OpenJDK.  </p>
<ul>
<li>查看当前安装的OpenJDK<br><code>rpm -qa | grep jdk</code><br>得到以下信息<br><code>java-1.7.0-openjdk.x86_64 1:1.7.0.99-2.6.5.1.el6</code>  </li>
<li>使用yum命令卸载<br><code>yum -y remove java-1.7.0-openjdk.x86_64 1:1.7.0.99-2.6.5.1.el6</code></li>
</ul>
<h3 id="安装SunJDK"><a href="#安装SunJDK" class="headerlink" title="安装SunJDK"></a>安装SunJDK</h3><ul>
<li><a href="http://pan.baidu.com/s/1qXCjosO" target="_blank" rel="external">JDK1.7下载地址</a></li>
<li>在linux上下载或从windows上传到linux上.<a href="http://pan.baidu.com/s/1hs3Spb2" target="_blank" rel="external">FTP工具</a></li>
<li>解压jdk<br><code>tar -zxvf jdk-7u79-linux-x64.tar.gz</code></li>
<li>将解压的得到的jdk1.7.0_79目录移动到<code>/usr/local</code>目录下并重命名为java1.7<br><code>mv jdk1.7.0_79 /usr/local/java1.7</code></li>
<li><p>配置环境变量<br>在当前用户家目录执行: <code>vim .bashrc</code><br>添加以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/local/java1.7</div><div class="line">export CLASSPATH=.:$JAVA_HOME/lib/</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
</li>
<li><p>让环境变量生效<br><code>source .bashrc</code></p>
</li>
<li>验证是否配置成功<br><code>java -version</code><br>得到以下信息说明配置成功了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version &quot;1.7.0_79&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.7.0_79-b15)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h2><ul>
<li><a href="http://pan.baidu.com/s/1jHDbyiq" target="_blank" rel="external">hadoop2.7.2下载地址</a></li>
<li>解压并移动到/usr/local目录下<br><code>tar -zxvf hadoop-2.7.2.tar.gz</code><br><code>mv hadoop-2.7.2 /usr/local/hadoop</code></li>
<li>配置环境变量<br><code>vim .bashrc</code><br>java和hadoop最终配置如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/local/java1.7</div><div class="line">export CLASSPATH=$JAVA_HOME/lib/</div><div class="line">export HADOOP_HOME=/usr/local/hadoop</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin/:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后 <code>source .bashrc</code></p>
<ul>
<li>查看是否配置成功<br><code>hadoop version</code><br>得到以下信息说明配置成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Hadoop 2.7.2</div><div class="line">Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r b165c4fe8a74265c792ce23f546c64604acf0e41</div><div class="line">Compiled by jenkins on 2016-01-26T00:08Z</div><div class="line">Compiled with protoc 2.5.0</div><div class="line">From source with checksum d0fda26633fa762bff87ec759ebe689c</div><div class="line">This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.7.2.jar</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="配置Hadoop分布式集群"><a href="#配置Hadoop分布式集群" class="headerlink" title="配置Hadoop分布式集群"></a>配置Hadoop分布式集群</h2><h3 id="修改hostname为master"><a href="#修改hostname为master" class="headerlink" title="修改hostname为master"></a>修改hostname为master</h3><p><code>vim /etc/sysconfig/network</code><br>改为: <code>HOSTNAME=master</code></p>
<h3 id="设置hosts文件使主机名和IP地址相对应"><a href="#设置hosts文件使主机名和IP地址相对应" class="headerlink" title="设置hosts文件使主机名和IP地址相对应"></a>设置hosts文件使主机名和IP地址相对应</h3><p><code>vim /etc/hosts</code><br>添加以下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.170.170 master  ## 本机IP</div><div class="line">192.168.170.171 slave1  ## 一会要设置的从节点IP</div><div class="line">192.168.170.172 slave2</div></pre></td></tr></table></figure></p>
<p><strong>其他两台slave的主机也修改对应的slave, slave2.如果修改完主机名后没有生效.那么重启系统便可以.三台机子的主机名与hosts均要修改</strong></p>
<h3 id="在hadoop文件夹下建立如下四个文件夹"><a href="#在hadoop文件夹下建立如下四个文件夹" class="headerlink" title="在hadoop文件夹下建立如下四个文件夹"></a>在hadoop文件夹下建立如下四个文件夹</h3><ul>
<li>目录/tmp, 用来存储临时生成的文件</li>
<li>目录/hdfs, 用来存储集群数据</li>
<li>目录hdfs/data, 用来存储真正的数据</li>
<li>目录hdfs/name, 用来存储文件系统元数据<br><code>mkdir tmp hdfs hdfs/data hdfs/name</code></li>
</ul>
<h3 id="配置hadoop文件"><a href="#配置hadoop文件" class="headerlink" title="配置hadoop文件"></a>配置hadoop文件</h3><p>在hadoop/etc/hadoop目录下,主要配置以下7个文件:</p>
<ul>
<li>slaves </li>
<li>hadoop-env.sh</li>
<li>yarn-env.sh</li>
<li>core-site.xml</li>
<li>mapred-site.xml</li>
<li>hdfs-site.xml</li>
<li>yarn-site.xml</li>
</ul>
<h4 id="修改slaves文件"><a href="#修改slaves文件" class="headerlink" title="修改slaves文件"></a>修改slaves文件</h4><p>修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<h4 id="修改hadoop-env-sh文件"><a href="#修改hadoop-env-sh文件" class="headerlink" title="修改hadoop-env.sh文件"></a>修改hadoop-env.sh文件</h4><p>将 <code>export JAVA_HOME=${JAVA_HOME}</code> 那一行改为 <code>export JAVA_HOME=/usr/local/java1.7</code> </p>
<h4 id="修改yarn-env-sh文件"><a href="#修改yarn-env-sh文件" class="headerlink" title="修改yarn-env.sh文件"></a>修改yarn-env.sh文件</h4><p>同样将 <code>export JAVA_HOME=${JAVA_HOME}</code> 那一行改为 <code>export JAVA_HOME=/usr/local/java1.7</code> </p>
<h4 id="修改core-site-xml文件"><a href="#修改core-site-xml文件" class="headerlink" title="修改core-site.xml文件"></a>修改core-site.xml文件</h4><p>配置为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">        &lt;value&gt;hdfs://master:9000&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class="line">        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;io.file.buffer.size&lt;/name&gt;</div><div class="line">        &lt;value&gt;131072&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h4 id="修改mapred-site-xml文件"><a href="#修改mapred-site-xml文件" class="headerlink" title="修改mapred-site.xml文件"></a>修改mapred-site.xml文件</h4><p>先把mapred-site.xml.template文件复制一份为mapred-site.xml再修改.<br>配置为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">        &lt;value&gt;yarn&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:10020&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:19888&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h4 id="修改hdfs-site-xml文件"><a href="#修改hdfs-site-xml文件" class="headerlink" title="修改hdfs-site.xml文件"></a>修改hdfs-site.xml文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class="line">        &lt;value&gt;file:/usr/local/hadoop/hdfs/name&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class="line">        &lt;value&gt;file:/usr/local/hadoop/hdfs/data&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">        &lt;value&gt;2&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:9001&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</div><div class="line">        &lt;value&gt;true&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h4 id="修改yarn-site-xml文件"><a href="#修改yarn-site-xml文件" class="headerlink" title="修改yarn-site.xml文件"></a>修改yarn-site.xml文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">		&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</div><div class="line">        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:8032&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:8030&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:8031&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:8033&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</div><div class="line">        &lt;value&gt;master:8088&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h2 id="关闭防火墙和SELinux"><a href="#关闭防火墙和SELinux" class="headerlink" title="关闭防火墙和SELinux"></a>关闭防火墙和SELinux</h2><p>切记一定要关闭,否则Hadoop启动会出错.</p>
<ul>
<li>关闭防火墙<br>查看防火墙状态: <code>service iptables status</code><br>若未关闭,则执行: <code>service iptables stop</code></li>
<li>关闭SELinux<br>查看SELinux状态: <code>getenforce</code><br>关闭SELinux: <code>setenforce 0</code>  <strong>系统重启后还会生效</strong><br>永久关闭: <code>vim /etc/selinux/config</code>  将selinux状态改为<code>disabled</code></li>
</ul>
<h2 id="安装并配置从节点"><a href="#安装并配置从节点" class="headerlink" title="安装并配置从节点"></a>安装并配置从节点</h2><ol>
<li>再安装两个虚拟机,重复以上步骤进行配置,这样有点麻烦也浪费时间,所以我们可以直接复制master节点的文件为两份,分别为slave1和slave2,这样就不用重复配置了,省事不少,然后在vmware里面打开.</li>
<li>因为从节点是复制的,所以网卡信息也复制了,将会导致从节点上不了网.因此,我们要在vmware里面点击打开的slave1节点,点击设置,选中网络适配器将其移除,然后再添加一块新的网络适配器(网卡).<strong>注意也要选择nat模式</strong>, slave2同理.然后同时启动slave1和slave2.  </li>
<li>启动后设置slave1节点IP为之前master设定好的IP: <code>192.168.170.171</code><br>slave2节点IP为: <code>192.168.170.172</code></li>
<li>修改hostname,将slave1和slave2节点的hostname分别改为slave1和slave2,参考master修改hostname.</li>
</ol>
<h2 id="实现免密码登陆"><a href="#实现免密码登陆" class="headerlink" title="实现免密码登陆"></a>实现免密码登陆</h2><p>hadoop各个节点之间需要数据通信,为了方便操作,在数据通信时,不要我们再逐台输入密码.我们需要配置免密码登录的ssh.</p>
<ol>
<li>使用以下命令在三台虚拟机上分别生成各自的公钥,私钥.<br><code>ssh-keygen -t rsa</code><br><strong>全部按回车进行生成,默认生成位置在家目录下的.ssh文件夹</strong></li>
<li>将master的公钥追加到authorized_keys中.<br><code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code></li>
<li>将slave1和slave2公钥追加到master的authorized_keys文件中.<br>在两台从节点都执行: <code>ssh-copy-id -i .ssh/id_rsa.pub master</code></li>
<li>将master的authorized_keys复制到两个从节点上<br><code>scp .ssh/authorized_keys slave1:~/.ssh/</code><br><code>scp .ssh/authorized_keys slave2:~/.ssh/</code></li>
<li>测试<br>在三台虚拟机上用ssh命令进行互相测试：ssh master, ssh slave1, ssh slave2.<br>以slave1为例:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[hadoop@slave1 ~]$ ssh master</div><div class="line">Last login: Thur Jul 20 13:16:39 2017 from slave2</div><div class="line">[hadoop@slave1 ~]$ ssh slave2</div><div class="line">Last login: Thur Jul 20 13:17:21 2017 from slave1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不需要密码,是不是方便多了呢。</p>
<h2 id="格式化hdfs文件系统"><a href="#格式化hdfs文件系统" class="headerlink" title="格式化hdfs文件系统"></a>格式化hdfs文件系统</h2><p>OK,到这,我们就算配置完成了.不过,我们要想使用hadoop,还需要格式化hdfs文件系统.<br>hadoop2.7.2版本的格式化命令也有变化,之前用hadoop namenode -format,现在是hdfs.<br>执行: <code>hdfs namenode -format</code><br>执行上面的命令后,在后面的提示中如果看到successfully formatted的字样,说明hdfs格式化成功! </p>
<h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><p><strong>所有启动关闭脚本在<code>/usr/local/hadoop/sbin</code>目录下</strong><br>之前版本使用 <code>start-all.sh</code> 一个脚本启动,但是我想看看它到底启动了什么,查看源代码后发现脚本里有这么一句话: “This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh”,表明已经过时了,要分别用start-dfs.sh 和 start-yarn.sh来启动.  </p>
<ul>
<li>启动dfs并查看进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[hadoop@master ~]$ start-dfs.sh</div><div class="line">17/07/20 13:42:52 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</div><div class="line">Starting namenodes on [master]</div><div class="line">master: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-master.out</div><div class="line">slave1: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hadoop-datanode-slave1.out</div><div class="line">slave2: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hadoop-datanode-slave2.out</div><div class="line">Starting secondary namenodes [master]</div><div class="line">master: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-secondarynamenode-master.out</div><div class="line">17/07/20 13:45:34 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</div><div class="line">[hadoop@master ~]$ jps</div><div class="line">27742 SecondaryNameNode</div><div class="line">27885 Jps</div><div class="line">27574 NameNode</div></pre></td></tr></table></figure>
</li>
</ul>
<p>出现的警告由于glibc版本(系统的是2.12, hadoop需要的是2.14)问题引起的,解决办法:<br>在<code>/usr/local/hadoop/etc/hadoop/log4j.properties</code> 文件最后添加: <code>log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR</code> 即可解决.</p>
<ul>
<li><p>启动yarn并查看进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[hadoop@master ~]$ start-yarn.sh</div><div class="line">starting yarn daemons</div><div class="line">starting resourcemanager, logging to /usr/local/hadoop/logs/yarn-hadoop-resourcemanager-master.out</div><div class="line">slave2: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hadoop-nodemanager-slave2.out</div><div class="line">slave1: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hadoop-nodemanager-slave1.out</div><div class="line">[hadoop@master ~]$ jps</div><div class="line">28053 ResourceManager</div><div class="line">27742 SecondaryNameNode</div><div class="line">28122 Jps</div><div class="line">27574 NameNode</div></pre></td></tr></table></figure>
</li>
<li><p>在从节点查看进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[hadoop@slave1 ~]$ jps</div><div class="line">4603 DataNode</div><div class="line">4932 Jps</div><div class="line">4785 NodeManager</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[hadoop@slave2 ~]$ jps</div><div class="line">5962 Jps</div><div class="line">5674 DataNode</div><div class="line">5830 NodeManager</div></pre></td></tr></table></figure>
<p>三台虚拟机状态都正常.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="在浏览器输入网址查看"><a href="#在浏览器输入网址查看" class="headerlink" title="在浏览器输入网址查看"></a>在浏览器输入网址查看</h3><p>输入 <code>192.168.170.170:8088</code> 或者 <code>192.168.170.170:50070</code> 能看到网页信息说明启动成功,可以查看节点信息.</p>
<h3 id="检验hadoop可用性"><a href="#检验hadoop可用性" class="headerlink" title="检验hadoop可用性"></a>检验hadoop可用性</h3><p>单纯的看进程和网页信息还不能完全的说明hadoop可用,我们要使用hadoop提供的 <code>hadoop-mapreduce-examples-2.7.2.jar</code> 包的wordcount功能检验一下hadoop是不是真的可以进行数据的分析.</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>在hdfs文件系统创建input文件夹: <code>hdfs dfs -mkdir /input</code></li>
<li>上传需要分析处理的数据文件: <code>hdfs dfs -put /usr/local/hadoop/*.txt /input</code></li>
<li>启动historyserver,不然下一步会报以下错误信息:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Caused by: java.net.ConnectException: 拒绝连接</div><div class="line">    at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)</div><div class="line">    at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:739)</div><div class="line">    at org.apache.hadoop.net.SocketIOWithTimeout.connect(SocketIOWithTimeout.java:206)</div><div class="line">    at org.apache.hadoop.net.NetUtils.connect(NetUtils.java:531)</div><div class="line">    at org.apache.hadoop.net.NetUtils.connect(NetUtils.java:495)</div><div class="line">    at org.apache.hadoop.ipc.Client$Connection.setupConnection(Client.java:614)</div><div class="line">    at org.apache.hadoop.ipc.Client$Connection.setupIOstreams(Client.java:712)</div><div class="line">    at org.apache.hadoop.ipc.Client$Connection.access$2900(Client.java:375)</div><div class="line">    at org.apache.hadoop.ipc.Client.getConnection(Client.java:1528)</div><div class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1451)</div><div class="line">    ... 33 more</div></pre></td></tr></table></figure>
<p>启动: <code>mr-jobhistory-daemon.sh start historyserver</code></p>
<h4 id="开始运行mapreduce"><a href="#开始运行mapreduce" class="headerlink" title="开始运行mapreduce"></a>开始运行mapreduce</h4><p>执行: <code>hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /input /output</code><br>具体如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">[hadoop@master ~]$ hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /test/input /test/output</div><div class="line">17/07/20 15:35:55 INFO client.RMProxy: Connecting to ResourceManager at master/192.168.170.170:8032</div><div class="line">17/07/20 15:36:05 INFO input.FileInputFormat: Total input paths to process : 3</div><div class="line">17/07/20 15:36:06 INFO mapreduce.JobSubmitter: number of splits:3</div><div class="line">17/07/20 15:36:09 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1502431075552_0003</div><div class="line">17/07/20 15:36:13 INFO impl.YarnClientImpl: Submitted application application_1502431075552_0003</div><div class="line">17/07/20 15:36:13 INFO mapreduce.Job: The url to track the job: http://master:8088/proxy/application_1502431075552_0003/</div><div class="line">17/07/20 15:36:13 INFO mapreduce.Job: Running job: job_1502431075552_0003</div><div class="line">17/07/20 15:38:39 INFO mapreduce.Job: Job job_1502431075552_0003 running in uber mode : false</div><div class="line">17/07/20 15:38:39 INFO mapreduce.Job:  map 0% reduce 0%</div><div class="line">17/07/20 15:42:34 INFO mapreduce.Job:  map 44% reduce 0%</div><div class="line">17/07/20 15:42:39 INFO mapreduce.Job:  map 78% reduce 0%</div><div class="line">17/07/20 15:42:40 INFO mapreduce.Job:  map 89% reduce 0%</div><div class="line">17/07/20 15:42:42 INFO mapreduce.Job:  map 100% reduce 0%</div><div class="line">17/07/20 15:44:08 INFO mapreduce.Job:  map 100% reduce 100%</div><div class="line">17/07/20 15:44:18 INFO mapreduce.Job: Job job_1502431075552_0003 completed successfully</div><div class="line">17/07/20 15:44:20 INFO mapreduce.Job: Counters: 49</div><div class="line">        File System Counters</div><div class="line">                FILE: Number of bytes read=12989</div><div class="line">                FILE: Number of bytes written=495819</div><div class="line">                FILE: Number of read operations=0</div><div class="line">                FILE: Number of large read operations=0</div><div class="line">                FILE: Number of write operations=0</div><div class="line">                HDFS: Number of bytes read=17212</div><div class="line">                HDFS: Number of bytes written=8983</div><div class="line">                HDFS: Number of read operations=12</div><div class="line">                HDFS: Number of large read operations=0</div><div class="line">                HDFS: Number of write operations=2</div><div class="line">        Job Counters</div><div class="line">                Launched map tasks=3</div><div class="line">                Launched reduce tasks=1</div><div class="line">                Data-local map tasks=3</div><div class="line">                Total time spent by all maps in occupied slots (ms)=781665</div><div class="line">                Total time spent by all reduces in occupied slots (ms)=59106</div><div class="line">                Total time spent by all map tasks (ms)=781665</div><div class="line">                Total time spent by all reduce tasks (ms)=59106</div><div class="line">                Total vcore-milliseconds taken by all map tasks=781665</div><div class="line">                Total vcore-milliseconds taken by all reduce tasks=59106</div><div class="line">                Total megabyte-milliseconds taken by all map tasks=800424960</div><div class="line">                Total megabyte-milliseconds taken by all reduce tasks=60524544</div><div class="line">        Map-Reduce Framework</div><div class="line">                Map input records=322</div><div class="line">                Map output records=2347</div><div class="line">                Map output bytes=24935</div><div class="line">                Map output materialized bytes=13001</div><div class="line">                Input split bytes=316</div><div class="line">                Combine input records=2347</div><div class="line">                Combine output records=897</div><div class="line">                Reduce input groups=840</div><div class="line">                Reduce shuffle bytes=13001</div><div class="line">                Reduce input records=897</div><div class="line">                Reduce output records=840</div><div class="line">                Spilled Records=1794</div><div class="line">                Shuffled Maps =3</div><div class="line">                Failed Shuffles=0</div><div class="line">                Merged Map outputs=3</div><div class="line">                GC time elapsed (ms)=31699</div><div class="line">                CPU time spent (ms)=34140</div><div class="line">                Physical memory (bytes) snapshot=413155328</div><div class="line">                Virtual memory (bytes) snapshot=3358351360</div><div class="line">                Total committed heap usage (bytes)=364929024</div><div class="line">        Shuffle Errors</div><div class="line">                BAD_ID=0</div><div class="line">                CONNECTION=0</div><div class="line">                IO_ERROR=0</div><div class="line">                WRONG_LENGTH=0</div><div class="line">                WRONG_MAP=0</div><div class="line">                WRONG_REDUCE=0</div><div class="line">        File Input Format Counters</div><div class="line">                Bytes Read=16896</div><div class="line">        File Output Format Counters</div><div class="line">                Bytes Written=8983</div></pre></td></tr></table></figure>
<p>查看处理后的数据:<br><code>hdfs dfs -cat /output/part-r-00000</code><br>大概如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">only    4</div><div class="line">or      67</div><div class="line">or,     1</div><div class="line">org.apache.hadoop.util.bloom.*  1</div><div class="line">origin  1</div><div class="line">original        2</div><div class="line">other   9</div><div class="line">otherwise       3</div><div class="line">otherwise,      3</div><div class="line">our     2</div><div class="line">out     1</div><div class="line">outstanding     1</div><div class="line">own     4</div><div class="line">owner   4</div><div class="line">owner.  1</div><div class="line">owner]  1</div><div class="line">ownership       2</div><div class="line">page&quot;   1</div><div class="line">part    4</div><div class="line">patent  5</div><div class="line">patent, 1</div><div class="line">percent 1</div><div class="line">perform,        1</div><div class="line">performing      1</div><div class="line">permission      1</div><div class="line">permission.     1</div><div class="line">permissions     3</div><div class="line">permitted       2</div><div class="line">permitted.      1</div><div class="line">perpetual,      2</div><div class="line">......</div></pre></td></tr></table></figure>
<p>数据有点多…<br>也可以在浏览器访问<code>192.168.170.170:50070</code>,点击<code>Utilities</code>下面的<code>Browse the file system</code>.在里面查看文件,也可以下载后查看.</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>至此,hadoop集群搭建完成,wordcount小例子完美运行.该休息下了 -_-||</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;搭建hadoo集群是学习大数据不可或缺的一步,然而自己练习又没有那么多台主机,只能在虚拟机上搭建了,自己也是第一次搭建,所以在这进行一些必要
    
    </summary>
    
      <category term="Bigdata" scheme="http://www.joahcy.com/categories/Bigdata/"/>
    
    
      <category term="bigdata" scheme="http://www.joahcy.com/tags/bigdata/"/>
    
      <category term="hadoop" scheme="http://www.joahcy.com/tags/hadoop/"/>
    
      <category term="cluster" scheme="http://www.joahcy.com/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHubPages搭建个人博客</title>
    <link href="http://www.joahcy.com/BuildBlog/buildBlog_Hexo_GitHub/"/>
    <id>http://www.joahcy.com/BuildBlog/buildBlog_Hexo_GitHub/</id>
    <published>2017-07-12T08:00:04.000Z</published>
    <updated>2017-08-05T03:46:21.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先,欢迎各位来参观我的博客: <a href="http://www.joahcy.com">Joahcy’s Blog</a>.搭建博客的目的呢?一方面总结自己学习各种技术过程中踩过的坑以及心得,另一方面希望通过博客这个平台与大家一起交流,共同进步.其实博客搭建完成已有一段时间了,但是之后一直没有时间写这个教程,今天天清气爽,闲来无事正好有时间来完成这个博文.废话不多说,下面就让我们开始搭建属于自己的博客,保证小白白都能看懂,开始吧!<br>如果你还不知道你为什么要做一个博客，推荐你看：<a href="http://www.cnblogs.com/jhzhu/p/3893297.html" target="_blank" rel="external">&lt;&lt;我为什么写博客&gt;&gt;</a><br><img src="http://oqwn6kueb.bkt.clouddn.com/sky-cloud.jpg" alt="此时风景正好"></p>
<h2 id="关于GitHub"><a href="#关于GitHub" class="headerlink" title="关于GitHub"></a>关于GitHub</h2><p>1.Github的优点</p>
<ul>
<li><a href="https://github.com/" target="_blank" rel="external">GitHub官网</a></li>
<li>GitHub是基于git实现的代码托管.git可能是目前最好用的版本控制系统了,非常受欢迎.</li>
<li>GitHub可以免费使用,并且快速稳定.</li>
<li>Github上面的世界很精彩,用久了你的眼界会开阔很多.</li>
</ul>
<p>2.什么是Github Pages?</p>
<ul>
<li>Github Pages可以被认为是用户编写的,托管在github上的静态网页.</li>
</ul>
<p>3.为什么要使用Github Pages?</p>
<ul>
<li>可以绑定你的域名(但暂时貌似只能绑定一个).</li>
<li>简单快捷,使用Github Pages可以为你提供一个免费的服务器,免去了自己搭建服务器和写数据库的麻烦.</li>
</ul>
<h2 id="关于Hexo"><a href="#关于Hexo" class="headerlink" title="关于Hexo"></a>关于Hexo</h2><p>1.Hexo是什么?</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网</a></li>
<li>正如官网所介绍的: A fast, simple &amp; powerful blog framework.Hexo 是一个快速、简洁且高效的博客框架。</li>
</ul>
<p>2.它有什么优点?</p>
<ul>
<li>速度快: 几十篇博文,只需数秒就可以生成静态网页</li>
<li>一键部署: 只需一条命令就可以完成部署</li>
<li>支持MarkDown语法</li>
<li>有丰富的插件库</li>
</ul>
<p>想要更多了解,还需各位自行上官网或Google.</p>
<h2 id="安装和使用Git"><a href="#安装和使用Git" class="headerlink" title="安装和使用Git"></a>安装和使用Git</h2><ol>
<li>安装<ul>
<li>Windows<br><a href="https://git-for-windows.github.io/" target="_blank" rel="external">官网下载</a>(可能有些慢)或<a href="http://pan.baidu.com/s/1c1FTy5U" target="_blank" rel="external">点此下载</a>,之后就是小白安装,这是<a href="http://blog.csdn.net/renfufei/article/details/41647875/" target="_blank" rel="external">安装详细教程</a></li>
<li>Linux<br><code>apt install git 或 yum install git</code></li>
</ul>
</li>
<li><p>怎么打开和使用git呢?<br><img src="http://oqwn6kueb.bkt.clouddn.com/git-bash.jpg" alt="右击鼠标点击GitBash"><br><img src="http://oqwn6kueb.bkt.clouddn.com/git-bash2.jpg" alt="命令行使用git"></p>
</li>
<li><p>Git基础操作<br><img src="http://oqwn6kueb.bkt.clouddn.com/git-cmds.png" alt="GIt基础操作"></p>
</li>
<li><p>Git教程: <a href="http://git.oschina.net/progit/" target="_blank" rel="external">ProGit(中文版)</a>  <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰GIt教程</a></p>
</li>
</ol>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ul>
<li>Windows<br>根据自己系统版本在<a href="https://nodejs.org/en/download/" target="_blank" rel="external">官网下载</a>安装即可.</li>
<li>Linux<br>  apt install nodejs</li>
</ul>
<h2 id="安装淘宝cnpm"><a href="#安装淘宝cnpm" class="headerlink" title="安装淘宝cnpm"></a>安装淘宝cnpm</h2><ul>
<li>npm 速度会有点慢,所以可以使用淘宝的cnpm代替npm,用法和npm几乎一样.</li>
<li>安装:  <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><ul>
<li>Windows 桌面右击鼠标,点击Git Bash Here,进入命令行,执行以上命令</li>
<li>Linux 直接在命令行执行以上命令</li>
</ul>
</li>
</ul>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cnpm install -g hexo-cli</div><div class="line">npm install hexo --save</div></pre></td></tr></table></figure>
</li>
<li><p>创建博客文件夹(比如:E:/blog/joahcy或/home/blog/joahcy)并初始化配置</p>
<ul>
<li>Windows 进入博客文件夹(如我的是joahcy文件夹),右击鼠标,点击Git Bash Here,进入命令行,执行以下操作</li>
<li>Linux 进入博客文件夹,执行以下操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>初始化并且依赖安装完成后,博客目录大概如下:<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog-dir.jpg" alt="初始化后目录"></p>
<ul>
<li><p>安装Hexo插件,保证后面操作不出错,在博客文件夹执行以下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-index --save</div><div class="line">npm install hexo-generator-archive --save</div><div class="line">npm install hexo-generator-category --save</div><div class="line">npm install hexo-generator-tag --save</div><div class="line">npm install hexo-server --save</div><div class="line">npm install hexo-deployer-git --save</div><div class="line">npm install hexo-deployer-heroku --save</div><div class="line">npm install hexo-deployer-rsync --save</div><div class="line">npm install hexo-deployer-openshift --save</div><div class="line">npm install hexo-renderer-marked@0.2 --save</div><div class="line">npm install hexo-renderer-stylus@0.2 --save</div><div class="line">npm install hexo-generator-feed@1 --save</div><div class="line">npm install hexo-generator-sitemap@1 --save</div></pre></td></tr></table></figure>
</li>
<li><p>生成静态文件<br><code>hexo g</code></p>
</li>
<li>测试,本地查看效果<ul>
<li>执行 <code>hexo s</code></li>
<li>浏览器访问: <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 测试是否成功(端口默认4000)<br><img src="http://oqwn6kueb.bkt.clouddn.com/blog-original.jpg" alt="博客雏形"></li>
</ul>
</li>
</ul>
<h2 id="将博客部署到Github上"><a href="#将博客部署到Github上" class="headerlink" title="将博客部署到Github上"></a>将博客部署到Github上</h2><ul>
<li>创建github账户,<a href="https://github.com/" target="_blank" rel="external">Github首页</a>点击右上角Sign up进行注册</li>
<li><p>创建项目代码库<br>  注册完成后,点击New repository. 注意名字一定是 yourname.github.io,如图所示:<br><img src="http://oqwn6kueb.bkt.clouddn.com/new-repo.jpg" alt="创建仓库"></p>
</li>
<li><p>配置SSH秘钥<br>配置Github的SSH密钥可以让本地git项目与远程的github建立联系,让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步.操作如下：<br>1.查看本机用户目录是否存在SSH秘<br>2.若不存在则创建新的秘钥,需填写自己的Github注册时的邮箱<br><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br>相关提示:</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
</code></pre><p>直接回车,直接回车,则将密钥按默认文件进行存储.<br>然后根据提示,输入密码和确认密码(其实可以不用密码,就是到输密码的地方,都直接回车,所以后面每次push就只需回车就可以).相关提示如下：</p>
<pre><code>Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
</code></pre><p>  输入完成之后，屏幕会显示如下信息：</p>
<pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
</code></pre><p>3.在GitHub账户中添加你的公钥,将公钥文件id_rsa.pub的内容复制<br>4.登录Github,右上角进入settings,然后左侧点击<code>SSH and GPG keys</code>,接着点击<code>New SSH key</code>,如图:<br><img src="http://oqwn6kueb.bkt.clouddn.com/new-sshkey.jpg" alt="New SSH key"><br>5.测试<br>可以输入下面的命令，看看设置是否成功<br><code>ssh -T git@github.com</code><br>如果出现下面的信息,则表示设置成功:</p>
<pre><code>Hi joahcy! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><p>6.配置用户信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;joahcy&quot;//用户名</div><div class="line">git config --global user.email  &quot;joahcy915@gmail.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>
</li>
</ul>
<p>至此秘钥配置完成,本机已与Github建立了联系.</p>
<ul>
<li><p>修改博客目录(E:/blog/joahcy)下的_config.yml配置文件 (注意: 配置时,每个键值对之间都要加个空格)<br>  1.根据个人情况修改Site,Url和Pagination部分<br>  2.修改Deploy部分<br>  登录Github打开项目username.github.io<br>  <img src="http://oqwn6kueb.bkt.clouddn.com/setup1.jpg" alt="打开项目"></p>
<p>  复制项目HTTPS路径<br>  <img src="http://oqwn6kueb.bkt.clouddn.com/setup2.jpg" alt="复制项目HTTPS路径"></p>
<p>  找到关键字deploy,进行如图修改,repository为刚才复制的路径<br>  <img src="http://oqwn6kueb.bkt.clouddn.com/setup4.jpg" alt="修改deploy"></p>
</li>
<li><p>部署<br>进入博客目录(E:/blog/joahcy),执行以下命令.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure>
</li>
</ul>
<p>或者直接执行<code>hexo g -d</code><br>执行完之后会让你输入github的账号和密码,输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了.对应的地址是 username.github.io(我的是：joahcy.github.io)<br>如果觉得输入用户名和密码麻烦,可以修改deploy部分的repository,如图:<br><img src="http://oqwn6kueb.bkt.clouddn.com/setup3.jpg" alt="修改为SSH连接"><br><img src="http://oqwn6kueb.bkt.clouddn.com/setup5.jpg" alt="修改"><br>这样部署的时候就不用输入用户名和密码,是不是方便多了?</p>
<h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p>通过浏览器访问自己的博客,地址为<a href="http://yourname.github.io" target="_blank" rel="external">http://yourname.github.io</a><br><img src="http://oqwn6kueb.bkt.clouddn.com/blog-original.jpg" alt="博客雏形"></p>
<h2 id="根据个人喜好修改博客主题"><a href="#根据个人喜好修改博客主题" class="headerlink" title="根据个人喜好修改博客主题"></a>根据个人喜好修改博客主题</h2><ul>
<li>1.在<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo官网</a>找到自己喜欢的主题,然后克隆下来.  (博客的主题都保存在博客根目录的themes文件夹下)<br>如克隆Next主题,进入博客目录,执行一下命令:<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></li>
<li>2.找到全局_config.yml文件的theme关键字,改为next.(注:值是themes文件夹下主题文件夹的名字)</li>
<li>3.详细修改主题样式配置<br>修改主题目录下的_config.yml文件,在这就不详细解释了,可以找相应的教程来修改(注:简洁大方next主题有很多教程,当然也有其他的主题)</li>
</ul>
<h2 id="通过域名访问博客"><a href="#通过域名访问博客" class="headerlink" title="通过域名访问博客"></a>通过域名访问博客</h2><ul>
<li>通过域名商购买自己喜欢的的域名(万网,西部数码,GoDaddy等等),我用的万网.<br>搜索<br><img src="http://oqwn6kueb.bkt.clouddn.com/domain1.jpg" alt="搜索"><br>找到可注册的域名<br><img src="http://oqwn6kueb.bkt.clouddn.com/domain2.jpg" alt="找到可注册的域名"><br>如果用的万网,进入个人中心,点击域名<br><img src="http://oqwn6kueb.bkt.clouddn.com/domain3.jpg" alt="进入个人中心"><br>点击域名后面的管理<br><img src="http://oqwn6kueb.bkt.clouddn.com/domain4.jpg" alt="点击管理"><br>修改DNS 为f1gns1.dnspod.net    和 f1gns2.dnspod.net<br><img src="http://oqwn6kueb.bkt.clouddn.com/domain5.jpg" alt="修改DNS"></li>
<li>在DNSPod官网注册账号,并添加DNS解析<br>进入域名解析<br><img src="http://oqwn6kueb.bkt.clouddn.com/DNS1.jpg" alt="进入域名解析"><br>添加域名<br><img src="http://oqwn6kueb.bkt.clouddn.com/DNS2.jpg" alt="添加域名"><br>获取博客IP地址:  CMD 里面  <code>ping  yourname.github.io</code> 得到IP<br>点击域名进去,添加两条记录,IP为刚才ping 得的ip<br><img src="http://oqwn6kueb.bkt.clouddn.com/DNS4.jpg" alt="添加记录"></li>
<li>在博客source目录下添加CNAME文件,内容为你的域名,然后再一次部署<br><code>hexo g -d</code></li>
<li>耐心等待……大约十几分钟就可以通过域名来访问了</li>
</ul>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><ul>
<li>用hexo发表新文章<br><code>hexo n &quot;文章标题&quot;</code><br>会在项目 source/_posts 中生成 对应的.md文件,用编辑器打开编写即可。<br>当然,也可以直接在source/_posts中新建一个md文件,写完后,推送到服务器上,执行以下命令即可在我们的站点看到新的文章.<br><code>hexo g -d</code></li>
<li>用Markdown写文章<ul>
<li>什么是markdown?<br>Markdown 是一种轻量级的「标记语言」,它的优点很多,目前也被越来越多的写作爱好者,撰稿者广泛使用.看到这里请不要被「标记」,「语言」所迷惑,Markdown 的语法十分简单.常用的标记符号也不超过十个,这种相对于更为复杂的HTML 标记语言来说,Markdown可谓是十分轻量的,学习成本也不需要太多,且一旦熟悉这种语法规则,会有一劳永逸的效果.</li>
<li>markdown有以下优点:<ul>
<li>专注你的文字内容而不是排版样式.</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件.</li>
<li>纯文本内容,兼容所有的文本编辑器与字处理软件.</li>
<li>可读,直观.适合所有人的写作语言.</li>
</ul>
</li>
<li>用什么工具写?<ul>
<li>Windows : MarkdownPad2</li>
<li>Mac :用Mou 或 Atom</li>
<li>Web端: 用简书</li>
</ul>
</li>
<li>更多资料可以查看: <a href="https://sspai.com/post/25137" target="_blank" rel="external">认识与入门 Markdown</a></li>
</ul>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>至此,博客基本搭建完成.搭建了2天很累,但是还是有一定的成就感的.以后的路还很长,好好写文章提高自己吧.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先,欢迎各位来参观我的博客: &lt;a href=&quot;http://www.joahcy.com&quot;&gt;Joahcy’s Blog&lt;/a&gt;.搭建博客
    
    </summary>
    
      <category term="博客折腾" scheme="http://www.joahcy.com/categories/Buildblog/"/>
    
    
      <category term="Hexo" scheme="http://www.joahcy.com/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.joahcy.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>单例模式与多线程</title>
    <link href="http://www.joahcy.com/DesignPatterns/singletonPattern-and-multithreading/"/>
    <id>http://www.joahcy.com/DesignPatterns/singletonPattern-and-multithreading/</id>
    <published>2017-06-04T16:00:00.000Z</published>
    <updated>2017-08-12T06:38:29.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式?"></a>什么是单例模式?</h2><p>单例模式是为确保一个类只有一个实例,并为整个系统提供一个全局访问点的一种模式方法.从概念中体现出了单例的一些特点:</p>
<ul>
<li>在任何情况下,单例类永远只有一个实例存在</li>
<li>单例需要有能力为整个系统提供这一唯一实例</li>
</ul>
<p>下面来详细看看多线程中的各版本单例模式是怎么实现的吧!</p>
<h2 id="立即加载-“饿汉模式”"><a href="#立即加载-“饿汉模式”" class="headerlink" title="立即加载/“饿汉模式”"></a>立即加载/“饿汉模式”</h2><p>调用方法之前实例已经被创建了<br>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyObject&#123;</div><div class="line">    </div><div class="line">    private static MyObject myObject = new MyObject();</div><div class="line">    </div><div class="line">    private MyObject()&#123;&#125;</div><div class="line">    </div><div class="line">    public static MyObject getInstance()&#123;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">668661813</div><div class="line">668661813</div><div class="line">668661813</div></pre></td></tr></table></figure>
<p>从结果可以看出,饿汉式可以实现线程安全的单例模式.</p>
<h2 id="延迟加载-“懒汉模式”"><a href="#延迟加载-“懒汉模式”" class="headerlink" title="延迟加载/“懒汉模式”"></a>延迟加载/“懒汉模式”</h2><p>调用get()方法时才创建实例<br>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line"></div><div class="line">    private static MyObject myObject = null;</div><div class="line">    private MyObject()&#123;&#125;</div><div class="line">    public static MyObject getInstance()&#123;</div><div class="line">        if(myObject==null)&#123;</div><div class="line">            myObject = new MyObject();</div><div class="line">        &#125;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1928052572</div><div class="line">417166340</div><div class="line">1928052572</div></pre></td></tr></table></figure>
<p>从结果可以发现,hashcode并不是唯一的,也就是说创建出了多例,存在非线程安全问题.那怎么办呢?有4种解决方案:</p>
<ul>
<li>同步方法,使用synchronized关键字</li>
<li>同步代码块</li>
<li>针对重要代码进行同步</li>
<li>使用DCL(Double-Check Locking)双检查机制,且DCL是大多数多线程结合单例模式使用的解决方案.(<strong><em>注:jdk1.5之前不能使用</em></strong>)</li>
</ul>
<h3 id="方案一-同步方法-使用synchronized关键字"><a href="#方案一-同步方法-使用synchronized关键字" class="headerlink" title="方案一: 同步方法,使用synchronized关键字"></a>方案一: 同步方法,使用synchronized关键字</h3><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line"></div><div class="line">    private static MyObject myObject = null;</div><div class="line">    private MyObject()&#123;&#125;</div><div class="line">    public static synchronized MyObject getInstance()&#123;</div><div class="line">        if(myObject==null)&#123;</div><div class="line">            myObject = new MyObject();</div><div class="line">        &#125;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">417166340</div><div class="line">417166340</div><div class="line">417166340</div></pre></td></tr></table></figure>
<p>结果显示,此方案可行.但是运行效率低下,下一个线程必须等上一个线程释放锁后,才可以继续执行.</p>
<h3 id="方案二-同步代码块"><a href="#方案二-同步代码块" class="headerlink" title="方案二: 同步代码块"></a>方案二: 同步代码块</h3><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line">    private static MyObject myObject = null;</div><div class="line"></div><div class="line">    private MyObject()&#123;&#125;</div><div class="line"></div><div class="line">    public static MyObject getInstance() &#123;</div><div class="line">        try &#123;</div><div class="line">            synchronized (MyObject.class) &#123;</div><div class="line"></div><div class="line">                if (myObject == null) &#123;</div><div class="line">                    //模拟在对象创建之前做一些准备性的工作</div><div class="line">                    Thread.sleep(3000);</div><div class="line">                    myObject = new MyObject();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1928052572</div><div class="line">1928052572</div><div class="line">1928052572</div></pre></td></tr></table></figure>
<p>结果显示该方案也可行,写法等同于方案一,全部代码都被上锁,运行效率也很低</p>
<h3 id="方案三-针对重要代码进行同步"><a href="#方案三-针对重要代码进行同步" class="headerlink" title="方案三: 针对重要代码进行同步"></a>方案三: 针对重要代码进行同步</h3><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line">    private static MyObject myObject = null;</div><div class="line"></div><div class="line">    private MyObject()&#123;&#125;</div><div class="line"></div><div class="line">    public static MyObject getInstance() &#123;</div><div class="line">        try &#123;</div><div class="line">            if (myObject == null) &#123;</div><div class="line">                //模拟在对象创建之前做一些准备性的工作</div><div class="line">                Thread.sleep(3000);</div><div class="line">                synchronized (MyObject.class) &#123;</div><div class="line">                    myObject = new MyObject();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1928052572</div><div class="line">1599065238</div><div class="line">417166340</div></pre></td></tr></table></figure>
<p>从结果看出,此方案并不能解决非线程安全问题.看看下一个解决方案.</p>
<h3 id="方案四-使用DCL-Double-Check-Locking-双检查机制"><a href="#方案四-使用DCL-Double-Check-Locking-双检查机制" class="headerlink" title="方案四: 使用DCL(Double-Check Locking)双检查机制"></a>方案四: 使用DCL(Double-Check Locking)双检查机制</h3><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line">    //使用volatile关键字保证其可见性,并禁止内存重排序来让DCL生效</div><div class="line">    private static volatile MyObject myObject = null;</div><div class="line"></div><div class="line">    private MyObject() &#123;&#125;</div><div class="line"></div><div class="line">    public static MyObject getInstance() &#123;</div><div class="line">        try &#123;</div><div class="line">            if (myObject == null) &#123;</div><div class="line">                //模拟在对象创建之前做一些准备性的工作</div><div class="line">                Thread.sleep(3000);</div><div class="line">                synchronized (MyObject.class) &#123;</div><div class="line">                    if(myObject == null)&#123;</div><div class="line">                        myObject = new MyObject();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1398828021</div><div class="line">1398828021</div><div class="line">1398828021</div></pre></td></tr></table></figure>
<p>虽然从结果看,DCL可以实现线程安全的单例模式,但这里还需深入讨论理解DCL机制,请看 <a href="http://ifeve.com/doublecheckedlocking/" target="_blank" rel="external">有关“双重检查锁定失效”的说明</a> , <a href="http://www.iteye.com/topic/875420" target="_blank" rel="external">Java线程安全兼谈DCL</a> ,<a href="http://blog.csdn.net/u014108122/article/details/38352005" target="_blank" rel="external">单例模式(DCL缺陷以及如何安全发布对象)</a> 这三篇文章来帮助我们深入理解java里面的DCL.</p>
<h2 id="使用静态内置类实现单例模式"><a href="#使用静态内置类实现单例模式" class="headerlink" title="使用静态内置类实现单例模式"></a>使用静态内置类实现单例模式</h2><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class MyObject &#123;</div><div class="line"></div><div class="line">    private MyObject()&#123;&#125;</div><div class="line">    //内部类</div><div class="line">    public static class MyObjectHandler&#123;</div><div class="line">        private static MyObject myObject = new MyObject(); </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static MyObject getInstance()&#123;</div><div class="line">        return MyObjectHandler.myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1879096508</div><div class="line">1879096508</div><div class="line">1879096508</div></pre></td></tr></table></figure>
<p>结果显示可以达到线程安全,但是遇到序列化对象时,使用默认的方法会得到多例.</p>
<h2 id="序列化与反序列化的单例模式实现"><a href="#序列化与反序列化的单例模式实现" class="headerlink" title="序列化与反序列化的单例模式实现"></a>序列化与反序列化的单例模式实现</h2><p>在多线程下,单例对象需要序列化和反序列化时,添加readResolve() 方法,就不会新创建对象.<br>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class MyObject implements Serializable&#123;</div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">    private MyObject()&#123;&#125;</div><div class="line">    //内部类</div><div class="line">    public static class MyObjectHandler&#123;</div><div class="line">        private static MyObject myObject = new MyObject(); </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static MyObject getInstance()&#123;</div><div class="line">        return MyObjectHandler.myObject;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected Object readResolve() throws ObjectStreamException&#123;</div><div class="line">        System.out.println(&quot;readrReslove&quot;);</div><div class="line">        return MyObjectHandler.myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //模拟序列化和反序列化</div><div class="line">    public static void saveAndRead() &#123;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            MyObject myObject=MyObject.getInstance();</div><div class="line">            FileOutputStream fos = new FileOutputStream(new File(&quot;myobjectfile.txt&quot;));</div><div class="line">            ObjectOutputStream oos = new ObjectOutputStream(fos);</div><div class="line">            oos.writeObject(myObject);</div><div class="line">            oos.close();</div><div class="line">            fos.close();</div><div class="line">            System.out.println(myObject.hashCode());</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            FileInputStream fis = new FileInputStream(new File(&quot;myobjectfile.txt&quot;));</div><div class="line">            ObjectInputStream ois = new ObjectInputStream(fis);</div><div class="line">            MyObject myObject = (MyObject) ois.readObject();</div><div class="line">            ois.close();</div><div class="line">            fis.close();</div><div class="line">            System.out.println(myObject.hashCode());</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">       Test.saveAndRead();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1087933741</div><div class="line">readrReslove</div><div class="line">1087933741</div><div class="line">1087933741</div><div class="line">readrReslove</div><div class="line">1087933741</div><div class="line">1087933741</div><div class="line">readrReslove</div><div class="line">1087933741</div></pre></td></tr></table></figure>
<p>结果显示,每次反序列化之前都会调用readResolve()方法,从而实现线程安全的单例模式.</p>
<h2 id="使用static代码块实现单例模式"><a href="#使用static代码块实现单例模式" class="headerlink" title="使用static代码块实现单例模式"></a>使用static代码块实现单例模式</h2><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line"></div><div class="line">    private static MyObject myObject = null;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        myObject = new MyObject();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static MyObject getInstance()&#123;</div><div class="line">        return myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">668661813</div><div class="line">668661813</div><div class="line">668661813</div></pre></td></tr></table></figure>
<p>结果显示,此单例模式也是线程安全的.</p>
<h2 id="使用enum枚举类型实现单例模式"><a href="#使用enum枚举类型实现单例模式" class="headerlink" title="使用enum枚举类型实现单例模式"></a>使用enum枚举类型实现单例模式</h2><p>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public enum MyEnumSingleton &#123;</div><div class="line"></div><div class="line">    singletonFactory;</div><div class="line">    </div><div class="line">    private MySingleton instance;</div><div class="line">    //使用enum时,构造方法被自动调用</div><div class="line">    private MyEnumSingleton()&#123;</div><div class="line">        instance=new MySingleton();</div><div class="line">    &#125;</div><div class="line">    public MySingleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//需要实现单例的类，比如数据库连接Connection</div><div class="line">class MySingleton&#123;</div><div class="line">    public MySingleton()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyEnumSingleton.singletonFactory.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">779325750</div><div class="line">779325750</div><div class="line">779325750</div></pre></td></tr></table></figure>
<p>结果显示也可行.</p>
<h2 id="完善使用enum枚举实现单例模式"><a href="#完善使用enum枚举实现单例模式" class="headerlink" title="完善使用enum枚举实现单例模式"></a>完善使用enum枚举实现单例模式</h2><p>前面虽然用enum实现了,但是枚举类型被暴露,违反了”职责单一原则”,需要完善一下.<br>实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyObject&#123;</div><div class="line">    </div><div class="line">    public enum MyEnumSingleton &#123;</div><div class="line"></div><div class="line">        singletonFactory;</div><div class="line">        </div><div class="line">        private MySingleton instance;</div><div class="line">        //使用enum时,构造方法被自动调用</div><div class="line">        private MyEnumSingleton()&#123;</div><div class="line">            instance=new MySingleton();</div><div class="line">        &#125;</div><div class="line">        public MySingleton getInstance()&#123;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static MySingleton getInstance()&#123;</div><div class="line">        return MyEnumSingleton.singletonFactory.getInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//需要实现单例的类，比如数据库连接Connection</div><div class="line">class MySingleton&#123;</div><div class="line">    public MySingleton()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        MyThread t1=new MyThread();</div><div class="line">        MyThread t2=new MyThread();</div><div class="line">        MyThread t3=new MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(MyObject.getInstance().hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">854728855</div><div class="line">854728855</div><div class="line">854728855</div></pre></td></tr></table></figure>
<p>结果显示也可行.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是线程安全的单例模式的所有版本,最近在看”Java多线程编程核心技术”,特此记录一下,以便日后好查看复习.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式?&quot;&gt;&lt;/a&gt;什么是单例模式?&lt;/h2&gt;&lt;p&gt;单例模式是为确保一个类只有一个实例,并为整个系统提供一个全局访问点的一种模式方法.从概念中体现出
    
    </summary>
    
      <category term="设计模式" scheme="http://www.joahcy.com/categories/DesignPatterns/"/>
    
    
      <category term="设计模式" scheme="http://www.joahcy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="多线程" scheme="http://www.joahcy.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CentOS桌面切换及配置</title>
    <link href="http://www.joahcy.com/Linux/CentOS-desktop-config/"/>
    <id>http://www.joahcy.com/Linux/CentOS-desktop-config/</id>
    <published>2017-06-04T16:00:00.000Z</published>
    <updated>2017-08-05T03:47:32.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置GNOME或者KDE为默认的启动桌面环境"><a href="#设置GNOME或者KDE为默认的启动桌面环境" class="headerlink" title="设置GNOME或者KDE为默认的启动桌面环境"></a>设置GNOME或者KDE为默认的启动桌面环境</h2><ul>
<li>方法1: 修改/etc/sysconfig/desktop，根据需要将“DESKTOP”后面的内容改为KDE或GNOME。</li>
<li>方法2: 在当前用户目录下建立“.xinitrc”这个文件（注意文件名前有一个点号，代表建立的是一个隐藏文件）,<br>文件的内容就一行startkde或gnome-session，根据自己的需要选择KDE或GNOME。<h2 id="GNOME和KDE的切换"><a href="#GNOME和KDE的切换" class="headerlink" title="GNOME和KDE的切换"></a>GNOME和KDE的切换</h2></li>
<li>1、如果需要切换到GNOME:<br><code>switchdesk gnome</code></li>
<li>2、如果需要切换到KDE:<br><code>switchdesk kde</code></li>
</ul>
<h2 id="CentOS7设置默认启动为字符界面"><a href="#CentOS7设置默认启动为字符界面" class="headerlink" title="CentOS7设置默认启动为字符界面"></a>CentOS7设置默认启动为字符界面</h2><ul>
<li>字符界面：sudo systemctl set-default multi-user.target    </li>
<li>图形界面：sudo systemctl set-default graphical.target</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设置GNOME或者KDE为默认的启动桌面环境&quot;&gt;&lt;a href=&quot;#设置GNOME或者KDE为默认的启动桌面环境&quot; class=&quot;headerlink&quot; title=&quot;设置GNOME或者KDE为默认的启动桌面环境&quot;&gt;&lt;/a&gt;设置GNOME或者KDE为默认的启动桌面
    
    </summary>
    
      <category term="Linux" scheme="http://www.joahcy.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.joahcy.com/tags/Linux/"/>
    
      <category term="CentOS" scheme="http://www.joahcy.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC发送DELETE和PUT请求</title>
    <link href="http://www.joahcy.com/SpringMVC/SpringMVC-HiddenHttpFilter/"/>
    <id>http://www.joahcy.com/SpringMVC/SpringMVC-HiddenHttpFilter/</id>
    <published>2017-06-04T16:00:00.000Z</published>
    <updated>2017-08-05T03:52:42.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解Restful"><a href="#了解Restful" class="headerlink" title="了解Restful"></a>了解Restful</h2><blockquote>
<p>Restful一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。  </p>
</blockquote>
<p>Rest 风格的 URL.</p>
<ul>
<li>GET（SELECT）：从服务器查询，可以在服务器通过请求的参数区分查询的方式。  </li>
<li>POST（CREATE）：在服务器新建一个资源，调用insert操作。  </li>
<li>PUT（UPDATE）：在服务器更新资源，调用update操作。  </li>
<li>DELETE（DELETE）：从服务器删除资源，调用delete语句</li>
</ul>
<p>以 CRUD Order为例:</p>
<ul>
<li>新增: /order POST </li>
<li>修改: /order/1 PUT update?id=1 </li>
<li>获取: /order/1 GET get?id=1 </li>
<li>删除: /order/1 DELETE delete?id=1</li>
</ul>
<h2 id="如何发送-PUT-请求和-DELETE-请求呢"><a href="#如何发送-PUT-请求和-DELETE-请求呢" class="headerlink" title="如何发送 PUT 请求和 DELETE 请求呢 ?"></a>如何发送 PUT 请求和 DELETE 请求呢 ?</h2><ul>
<li><p>1.web.xml需要配置 HiddenHttpMethodFilter  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 把POST 转为DELETE和PUT请求 --&gt;</div><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>2.需要发送 POST 请求并携带一个 name=”_method” 的隐藏域, 值为 DELETE 或 PUT<br>  发送PUT请求</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;springmvc/testRestPut/2&quot; method=&quot;post&quot;&gt;</div><div class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;Test Rest PUT&quot;/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>  发送DELETE请求</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;springmvc/testRestDelete/2&quot; method=&quot;post&quot;&gt;</div><div class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;Test Rest DELETE&quot;/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="在Controller中添加方法-响应PUT和DELETE请求"><a href="#在Controller中添加方法-响应PUT和DELETE请求" class="headerlink" title="在Controller中添加方法,响应PUT和DELETE请求"></a>在Controller中添加方法,响应PUT和DELETE请求</h2><p>注:用 @PathVariable 注解得到请求URL中的id.<br>响应PUT请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/springmvc/testRestPut/&#123;id&#125;&quot;,method=RequestMethod.PUT)</div><div class="line">public String testRestPut(@PathVariable Integer id)&#123;</div><div class="line">	System.out.println(&quot;test rest PUT:&quot;+id);</div><div class="line">	return SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>响应DELETE请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/springmvc/testRestDelete/&#123;id&#125;&quot;,method=RequestMethod.DELETE)</div><div class="line">public String testRestDelete(@PathVariable Integer id)&#123;</div><div class="line">	System.out.println(&quot;test rest DELETE:&quot;+id);</div><div class="line">	return SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="启动测试项目进行请求测试"><a href="#启动测试项目进行请求测试" class="headerlink" title="启动测试项目进行请求测试"></a>启动测试项目进行请求测试</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;了解Restful&quot;&gt;&lt;a href=&quot;#了解Restful&quot; class=&quot;headerlink&quot; title=&quot;了解Restful&quot;&gt;&lt;/a&gt;了解Restful&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Restful一种软件架构风格，设计风格而不是标准，只是提
    
    </summary>
    
      <category term="SpringMVC" scheme="http://www.joahcy.com/categories/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://www.joahcy.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装JDK</title>
    <link href="http://www.joahcy.com/Java/install-JDK-on-linux/"/>
    <id>http://www.joahcy.com/Java/install-JDK-on-linux/</id>
    <published>2017-06-01T16:00:00.000Z</published>
    <updated>2017-08-05T03:47:14.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="去官网下载自己需要的linux的JDK版本"><a href="#去官网下载自己需要的linux的JDK版本" class="headerlink" title="去官网下载自己需要的linux的JDK版本"></a>去官网下载自己需要的linux的JDK版本</h2><h2 id="解压jdk到当前目录"><a href="#解压jdk到当前目录" class="headerlink" title="解压jdk到当前目录"></a>解压jdk到当前目录</h2><p><code>tar -zxvf jdk-8u60-linux-x64.tar.gz</code><br>得到文件夹 jdk1.8.0_60</p>
<h2 id="安装完毕为它建立一个链接以节省目录长度"><a href="#安装完毕为它建立一个链接以节省目录长度" class="headerlink" title="安装完毕为它建立一个链接以节省目录长度"></a>安装完毕为它建立一个链接以节省目录长度</h2><p>(我没用这一步)<br><code>ln -s /usr/java/jdk1.8.0_60/ /usr/jdk</code></p>
<h2 id="编辑配置文件，配置环境变量"><a href="#编辑配置文件，配置环境变量" class="headerlink" title="编辑配置文件，配置环境变量"></a>编辑配置文件，配置环境变量</h2><p><code>vim /etc/profile</code><br>添加如下内容：JAVA_HOME根据实际目录来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/usr/java/jdk1.8.0_60</div><div class="line">CLASSPATH=$JAVA_HOME/lib/</div><div class="line">PATH=$PATH:$JAVA_HOME/bin</div><div class="line">export PATH JAVA_HOME CLASSPATH</div></pre></td></tr></table></figure></p>
<h2 id="重启机器或执行命令"><a href="#重启机器或执行命令" class="headerlink" title="重启机器或执行命令:"></a>重启机器或执行命令:</h2><p><code>source /etc/profile</code>或者<code>sudo shutdown -r now</code></p>
<h2 id="查看安装情况"><a href="#查看安装情况" class="headerlink" title="查看安装情况"></a>查看安装情况</h2><p><code>java -version</code><br>得到以下信息就说明安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version &quot;1.8.0_60&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_60-b27)</div><div class="line">Java HotSpot(TM) Client VM (build 25.60-b23, mixed mode)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;去官网下载自己需要的linux的JDK版本&quot;&gt;&lt;a href=&quot;#去官网下载自己需要的linux的JDK版本&quot; class=&quot;headerlink&quot; title=&quot;去官网下载自己需要的linux的JDK版本&quot;&gt;&lt;/a&gt;去官网下载自己需要的linux的JDK版本&lt;/
    
    </summary>
    
      <category term="Java" scheme="http://www.joahcy.com/categories/Java/"/>
    
    
      <category term="JDK" scheme="http://www.joahcy.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://www.joahcy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB总结</title>
    <link href="http://www.joahcy.com/MongoDB/MongoDB-Summary/"/>
    <id>http://www.joahcy.com/MongoDB/MongoDB-Summary/</id>
    <published>2017-05-31T16:00:00.000Z</published>
    <updated>2017-08-05T03:47:42.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、操作数据库"><a href="#一、操作数据库" class="headerlink" title="一、操作数据库"></a>一、操作数据库</h2><ol>
<li>创建和切换数据库 ：<code>use dbName</code></li>
<li>查看数据库 ：<code>show dbs</code></li>
<li>删除数据库 ：<code>db.dropDatabase()</code></li>
</ol>
<h2 id="二、操作集合"><a href="#二、操作集合" class="headerlink" title="二、操作集合"></a>二、操作集合</h2><ol>
<li>查看集合 ：<code>show collections</code></li>
<li>删除集合 ：<code>db.集合名称.drop()</code></li>
<li>插入数据 ：<code>db.集合名称.insert({&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;})</code></li>
<li><p>插入多条数据 ：</p>
<ul>
<li><p>插入数组：<br>  <code>db.集合名称.insert([{&quot;url&quot;:&quot;www.sina.com&quot;,&quot;name&quot;:&quot;新浪&quot;},{&quot;url&quot;:&quot;www.baidu.com&quot;}]);</code></p>
</li>
<li><p>循环插入<br>  <code>for(var i=0;i&lt;10;i++){db.集合名称.insert({&quot;url&quot;:&quot;zyx-&quot;+i};}</code></p>
</li>
</ul>
</li>
<li><p>查询数据：<code>db.集合名称.find({查询条件}[,{设置显示的字段}])</code></p>
<ul>
<li><p>查询所有数据 ：<code>db.集合名称.find()</code></p>
</li>
<li><p>查询一条数据 ：<code>db.集合名称.findOne()</code></p>
</li>
<li><p>带条件查询：<br>  例：查询name为zyx 的记录 — <code>db.infos.find({&quot;name&quot;:&quot;zyx&quot;})</code></p>
</li>
<li><p>设置查询的字段(投影操作) ：要查的设为1，不查设为0  (不建议这么查)</p>
<p>  例：查询所有url的记录不带_id — <code>db.infos.find({查询条件},{&quot;_id&quot;:0,&quot;url&quot;:1})</code></p>
</li>
<li><p>关系查询：大于($gt)，大于等于($gte)，小于($lt)，小于等于($lte)，不等于($ne)，等于(k:v,$eq)</p>
<p>  例1：查询分数大于等于60的</p>
<pre><code>`db.students.find({&quot;score&quot;:{&quot;$gte&quot;:60}},{&quot;_id&quot;:0})`
</code></pre><p>  例2：查询性别是男的</p>
<pre><code>`db.students.find({&quot;sex&quot;:&quot;男&quot;},{&quot;_id&quot;:0})`
</code></pre><p>  例3：查询年龄小于20的</p>
<pre><code>`db.students.find({&quot;age&quot;:{&quot;$lt&quot;:20}},{&quot;_id&quot;:0})`
</code></pre><p>  例4：查询姓名不是王五的</p>
<pre><code>`db.students.find({&quot;name&quot;:{&quot;$ne&quot;:&quot;王五&quot;}},{&quot;_id&quot;:0})`
</code></pre></li>
<li><p>逻辑查询：与($and),或($or),非($not,$nor)</p>
<p>  例1：查询分数大于60且小于80的记录</p>
<pre><code>`db.students.find({&quot;score&quot;:{&quot;$gt&quot;:60,&quot;$lt&quot;:80}},{&quot;_id&quot;:0}).pretty()`
</code></pre><p>  例2：查询年龄大于19且分数大于80的记录</p>
<pre><code>`db.students.find({&quot;$or&quot;:[
    {&quot;age&quot;:{&quot;$gt&quot;:19}},
    {&quot;score&quot;:{&quot;$gt&quot;:80}}
]}).pertyy()`
</code></pre><p>  例3：查询年龄小于等于19且分数小于等于80的记录(即是对例2取非)</p>
<pre><code>`db.students.find({&quot;$nor&quot;:[
    {&quot;age&quot;:{&quot;$gt&quot;:19}},
    {&quot;score&quot;:{&quot;$gt&quot;:80}}
]}).pertyy()`
</code></pre><p>  例4：查询年龄在10岁到20岁和30到40岁之间的记录</p>
<pre><code>`db.person.find({&quot;$or&quot;:[{&quot;age&quot;:{&quot;$gt&quot;:10,&quot;$lt&quot;:20}},
{&quot;age&quot;:{&quot;$gt&quot;:30,&quot;$lt&quot;:40}}]},{&quot;_id&quot;:0}).pretty()`
</code></pre></li>
<li><p>求模：<code>$mod</code>：语法  <code>{$mod:[数字,余数]}</code></p>
<p>  例：查询年龄为21的记录</p>
<pre><code>`db.students.find({&quot;age&quot;:{&quot;$mod&quot;:[21,1]}}).pretty()`
</code></pre></li>
<li><p>范围查询：</p>
<p>  在范围内：<code>$in</code> 语法：<code>{$in:[&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;]}</code></p>
<p>  例：查询姓名是“张三”，“李四”，“王五”的信息<br>  <code>db.students.find({&quot;name&quot;:{&quot;$in&quot;:[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]}}).pretty()</code></p>
<p>  不在范围内：<code>$nin</code> 语法：<code>{$nin:[&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;]}</code></p>
<p>  例：查询姓名是“张三”，“李四”，“王五”的信息<br>  <code>db.students.find({&quot;name&quot;:{&quot;$nin&quot;:[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]}}).pretty()</code></p>
</li>
<li><p>数组： 几个运算符：<code>$all,$size,$slice,$elemMatch</code></p>
<p>  <em>*</em>注：①$all不仅可以用于数组上，也可以用于一个数据上</p>
<pre><code>②可以用索引进行操作：key.index(index下标从0开始)
③$slice可以对数组信息进行切片
    n:表示返回前n个
    -n:表示返回后n个
</code></pre></li>
</ul>
</li>
</ol>
<pre><code>        [3,4]:表示跳过1个，返回4个***

例1：查询报了课程语文、数学的学生信息
    `db.students.find({&quot;course&quot;:{&quot;$all&quot;:[&quot;语文&quot;,&quot;数学&quot;]}}).pretty()`

例2：查询地址在临潼区的学生(用$all)
    `db.students.find({&quot;loc&quot;:{&quot;$all&quot;:[&quot;临潼区&quot;]}}).pretty()`

例3：查询报了3门课程的学生信息
    `db.students.find({&quot;course&quot;:{&quot;$size&quot;:3}}).pretty()`

例4：查询第一门课是语文的学生
    `db.students.find({&quot;course.1&quot;:&quot;数学&quot;}).pretty()`

例5：查询年龄是19岁且只要求显示两门课程

(1)显示前两门
    `db.students.find({&quot;age&quot;:19},{&quot;course&quot;:{&quot;$slice&quot;:2}}).pretty()`

(2)显示后两门
    `db.students.find({&quot;age&quot;:19},{&quot;course&quot;:{&quot;$slice&quot;:2}}).pretty()`

(3)跳过2门,显示3门
    `db.students.find({&quot;age&quot;:19},{&quot;course&quot;:{&quot;$slice&quot;:[2,3]}}).pretty()`

嵌套查询：

例：查询年龄大于等于19岁且父母有是工人的学生信息
        `db.students.find({&quot;$and&quot;:[{&quot;age&quot;:{&quot;$gte&quot;:19}},{&quot;parents&quot;:{&quot;$elemMatch&quot;:{&quot;job&quot;:&quot;工人&quot;}}}]}).pretty()`
判断某个字段是否存在：$exists

例1：查询有字段parents的学生信息
    `db.students.find({&quot;parents&quot;:{&quot;$exists&quot;:true}}).pretty()`
例2：查询不具有字段course的学生信息
    `db.students.find({&quot;course&quot;:{&quot;$exists&quot;:false}}).pretty()`
where查询
例：查询年龄大于20的
`db.students.find({&quot;$where&quot;:&quot;this.age&gt;20&quot;}).pretty()
db.students.find(&quot;this.age&gt;20&quot;).pretty()
db.students.find(function(){
    return this.age&gt;20;
}).pretty()
db.students.find({&quot;$where&quot;:function(){
    return this.age&gt;20;
}}).pretty()`

正则表达式:
    基础语法：`{key:正则标记}`
    完整语法：`{&quot;$regex&quot;:正则标记,&quot;$options&quot;:选项}`
    例1：查询名字已张开头的学生信息
        `db.students.find({&quot;name&quot;:/^张/}).pretty()`
    例2：查询名字中含有a的学生信息
        `db.students.find({&quot;name&quot;:/a/i}).pretty()`//  i:区分大小写
        `db.students.find({&quot;name&quot;:{$regex:/a/i}}).pretty()`
        `db.students.find({&quot;name&quot;:{&quot;$regex&quot;:/a/,&quot;$options&quot;:&quot;$i&quot;}}).pretty()`
    例3：查询coures带有“语”的学生信息
        `db.students.find({&quot;course&quot;:/语/}).pretty()`
排序：sort() 函数   1:升序   -1:降序   `$natural`：自然顺序(记录插入顺序)  
    例1：根据成绩降序排序 
        `db.students.find().sort({&quot;score&quot;:-1}).pretty()`
        `db.students.find().sort({&quot;$natural&quot;:-1}).pretty()`
分页：
    `skip(n)`：表示跨过多少数据行
    `limit(n)`：取出的数据行的个数显示
    例1：分页显示(第一页：skip(0),limit(5)),并且score降序显示
        `db.students.find().skip(0).limit(5).sort({&quot;score&quot;:-1}).pretty()`
    例1：分页显示(第二页：skip(0),limit(5)),并且score降序显示
        `db.students.find().skip(5).limit(5).sort({&quot;score&quot;:-1}).pretty()`
</code></pre><ol>
<li><p>数据更新<br><code>update()</code>函数</p>
<pre><code>语法：`db.集合.update(更新条件，新的对象数据，upsert，mutil);`
    |- upsert：如果要更新的数据不存在，则增加一条新的内容(true:增加，false:不增加)
    |- mutil：表示是否只更新满足条件的第一行数据(true:全更新，false：只更新第一条)
例1：（更新存在的数据）将年龄为19岁的学生成绩更新为100
    `db.students.update({&quot;age&quot;:19},{&quot;$set&quot;:{&quot;score&quot;:100}},false,false)`
例2：（更新不存在的数据）将年龄为30岁的学生成绩更新为71
    `db.students.update({&quot;age&quot;:30},{&quot;$set&quot;:{&quot;score&quot;:100}},false,false)`
</code></pre><p><code>save()</code>函数：根据_id更新，_id存在就更新，不存在就插入一条数据</p>
<pre><code>例：更新_id为58664e79749d012a9fb04022的学生年龄为50
    `db.students.save({&quot;_id&quot; : ObjectId(&quot;fff64e79749d012a9fb04022&quot;),&quot;age&quot;:90})`
</code></pre><p>修改器：10种修改器</p>
<pre><code>(1) `$inc`：语法  `{&quot;$inc&quot;:{&quot;字段&quot;:内容}}`    (increase)
    例：将年龄为19岁的学生的score减30且age加1岁
        `db.students.update({&quot;age&quot;:19},{&quot;$inc&quot;:{&quot;score&quot;:-30,&quot;age&quot;:1}},false,true)`
 (2) `$set`：语法  `{&quot;$set&quot;:{&quot;字段&quot;:&quot;新内容&quot;}}`
     例：将年龄为20岁的score设为68分
         `db.students.update({&quot;age&quot;:20},{&quot;$set&quot;:{&quot;score&quot;:68}})`
 (3) `$unset`: 删除某个字段   语法  `{&quot;$set&quot;:{&quot;字段&quot;:1}}`
     例：将name为张三的age和score删除
         `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$unset&quot;:{&quot;age&quot;:1,&quot;score&quot;:1}})`
 (4) `$push`: 追加内容到指定的成员之中(基本是数组)
         语法：`{&quot;$push&quot;:{&quot;成员&quot;:&quot;内容&quot;}}`
         例：给张三添加一门课程“语文”
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$push&quot;:{&quot;course&quot;:&quot;语文&quot;}})`
 (5) `$pushAll`:与`$push`是类似的，但可以追加多个内容到字段中
         语法：`{&quot;$pushAll&quot;:{&quot;成员&quot;:数组内容}}`
         例：给张三添加课程政治，美术，体育
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$pushAll&quot;:{&quot;course&quot;:[&quot;政治&quot;,&quot;美术&quot;,&quot;体育&quot;]}})`
 (6) `$addToSet`:向数组里添加一个新的内容，只有当内容不存在时，才会添加
         语法：`{&quot;$addToSet&quot;:{&quot;成员&quot;:内容}}`
         例：给张三添加一门英语
             `db.students.update({&quot;nmae&quot;:&quot;张三&quot;},{&quot;$addToSet&quot;:{&quot;course&quot;:&quot;英语&quot;}})`
 (7) `$pop`:删除数组内的数据
         语法：`{&quot;$pop&quot;:{&quot;成员&quot;:内容}}` 内容为-1表示删除第一个，为1删除最后一个
         例：删除张三第一门课程
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$pop&quot;:{&quot;coures&quot;:-1}})`
 (8) `$pull`:从数组内删除以一个指定内容的数据
         语法：`{&quot;$pull&quot;:{&quot;成员&quot;:&quot;数据&quot;}}`，此数据为要删除的数据
         例：删除张三 的英语课程
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$pull&quot;:{&quot;course&quot;:&quot;英语&quot;}})`
 (9) `$pullAll`:一次删除多个内容
         语法：`{&quot;$pullAll&quot;:{&quot;成员&quot;:数组内容}}`
         例：删除张三的政治体育课程
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$pullAll&quot;:{&quot;course&quot;:[&quot;音乐&quot;,&quot;体育&quot;]}})`
 (10)`$rename`: 修改字段的名称
         语法：`{&quot;$rename&quot;:{&quot;旧的成员名称&quot;:&quot;新的成员名称&quot;}}`
         例：讲张三的“name”字段改名为“姓名”
             `db.students.update({&quot;name&quot;:&quot;张三&quot;},{&quot;$rename&quot;:{&quot;name&quot;:&quot;姓名&quot;}})`
</code></pre></li>
<li><p>数据删除<br><code>remove()</code>函数：有两个可选项</p>
<pre><code>删除条件：满足条件的数据被删除
是否只删除第一个数据(默认删除全部满足条件的)：如果设为true或1,则删除第一条满足条件 的
例1：删除集合的全部信息
    `db.infos.remove({})`    3.x
例2：删除name有“张”的学生信息
    `db.students.remove({&quot;name&quot;:/张/})`
例2：删除name有“张”的学生信息
    `db.students.remove({&quot;name&quot;:/王/},true)`
</code></pre></li>
<li><p>游标：类似于ResultSet<br>是否有下一个：<code>hasNext()</code><br>下一个：<code>next()</code><br>例：逐行打印students的姓名</p>
<pre><code>`var cursor=db.students.find();
while(cursor.hasNext()){
    var doc=cursor.next();
    print(doc.name);
}`
</code></pre><p>注：游标取出来的内容是Object类型的,如果需要将数据以json的形式打印，可以用<code>printjson()</code>函数。<br>例：`var cursor=db.students.find();</p>
<pre><code>while(cursor.hasNext()){
    var doc=cursor.next();
    printjson(doc);
}`
</code></pre></li>
<li><p>索引：提升数据检索性能<br>查看集合默认索引状态：</p>
<pre><code>`db.集合.getIndexes()`
`db.students.getIndexes()`
</code></pre><ul>
<li>创建索引：<br>  <code>db.集合.ensureIndex({字段:1})</code> 1表示索引按照升序排列，-1为降序<br>  注：索引的名称是自动命名的。命名规范：字段名称_索引排序模式<br>  例：<code>db.students.ensureIndex({&quot;age&quot;:-1})</code><br>针对当前的age字段上的索引做一个分析<br>  <code>db.students.find({&quot;age&quot;:19}).explain();</code>    扫描方式：IXSCAN<br>针对score字段查询<br>  <code>db.students.find({&quot;score&quot;:{&quot;$gt&quot;:60}}).explain();</code> 扫描方式：COLLSCAN</li>
<li>创建复合索引：<br>  <code>db.students.ensureIndex({&quot;age&quot;:-1,&quot;score&quot;:-1},{&quot;name&quot;:&quot;age_-1_score_-1_index&quot;})</code></li>
<li><p>强制使用索引<br>  <code>hint({&quot;age&quot;:-1,&quot;score&quot;:-1})</code></p>
</li>
<li><p>删除索引<br>  删除一个索引：<code>db.students.dropIndex({&quot;age&quot;:-1,&quot;score&quot;:-1})</code><br>  删除全部索引(除“_id”的索引)：<code>db.students.dropIndexes()</code></p>
</li>
<li><p>唯一索引：用在某个字段上，使该字段的内容不重复,如果有某个文档没有该字段，则会创建不成功<br>  创建：<code>db.students.ensureIndex({&quot;name&quot;:1},{&quot;unique&quot;:true})</code><br>  <code>db.stduents.insert({&quot;name&quot;:&quot;张三&quot;})</code><br>  如果插入的文档的内容在该字段上相同则会报错：</p>
<pre><code>`E11000 duplicate key error collection: zyx.students index: name_1 dup key`
</code></pre></li>
<li>过期索引：要实现过期索引，需要保存一个时间字段,但是这个时间往往不怎么准确<br>  创建：<br>  <code>db.集合.ensureIndex({&quot;time&quot;:1},{expireAfterSeconds:10})</code><br>  例：<pre><code>创建一个手机验证码集合，并设置10秒过期
`db.phones.ensureIndex({&quot;time&quot;:1},{expireAfterSeconds:10})
db.phones.insert({&quot;tel&quot;:110,&quot;code&quot;:000,&quot;time&quot;:new Date()})
db.phones.insert({&quot;tel&quot;:111,&quot;code&quot;:001,&quot;time&quot;:new Date()})
db.phones.insert({&quot;tel&quot;:112,&quot;code&quot;:002,&quot;time&quot;:new Date()})
db.phones.insert({&quot;tel&quot;:113,&quot;code&quot;:003,&quot;time&quot;:new Date()})
db.phones.insert({&quot;tel&quot;:114,&quot;code&quot;:004,&quot;time&quot;:new Date()})
db.phones.insert({&quot;tel&quot;:115,&quot;code&quot;:005,&quot;time&quot;:new Date()})`
</code></pre></li>
<li>全文索引：<br>  为某几个字段设置全文索引：<pre><code>创建：`{&quot;字段1&quot;:&quot;text&quot;,&quot;字段2&quot;:&quot;text&quot;}`   
模糊查询：
    要实现全文检索，则使用`&quot;$text&quot;`判断符，而要想进行数据的查询则使用`&quot;$search&quot;`
    |- 查询指定关键字：`{&quot;$search&quot;:&quot;查询关键字&quot;}`
    |- 查询多个关键字(或关系)：`{&quot;$search&quot;:&quot;查询关键字1 查询关键字2 ...&quot;}`
    |- 查询多个关键字(与关系)：`{&quot;$search&quot;:&quot;\&quot;查询关键字1\&quot; \&quot;查询关键字2\&quot;         ...&quot;}`
    |-查询多个关键字(排除某一个)：`{&quot;$search&quot;:&quot;查询关键字1 查询关键字2 ... -    排除关键字&quot;}`
    例：`db.students.find({&quot;$text&quot;:{&quot;$search&quot;:&quot;关键字&quot;})`
使用相似度的打分来判断检索结果：默认升序，分数越高越准确
    `db.students.find({&quot;$text&quot;:{&quot;$search&quot;:&quot;关键字&quot;}},{&quot;score&quot;:{&quot;$meta&quot;:&quot;textScore&quot;}})`
    排序操作：
        `db.students.find({&quot;$text&quot;:{&quot;$search&quot;:&quot;关键字&quot;}},{&quot;score&quot;:{&quot;$meta&quot;:&quot;textScore&quot;}}).sort({&quot;score&quot;:{&quot;$meta&quot;:&quot;textScore&quot;}})`
</code></pre>  为所有字段设置全文索引：<br>  <code>db.集合.ensureIndex({&quot;$**&quot;:&quot;text&quot;})</code><pre><code>注：尽可能别用。。。因为慢
</code></pre></li>
<li>地理信息索引：分为两类 ①2D平面索引②2DShere球面索引<br>  为集合定义2D索引：<br>  <code>db.集合.ensureIndex({&quot;字段&quot;:&quot;2d&quot;})</code><br>  例：<pre><code>创建2d索引：
    `db.shop.ensureIndex({&quot;loc&quot;:&quot;2d&quot;})`
创建集合：
    `db.shop.insert({&quot;loc&quot;:[10,10]})
    db.shop.insert({&quot;loc&quot;:[11,10]})
    db.shop.insert({&quot;loc&quot;:[11,11]})
    db.shop.insert({&quot;loc&quot;:[13,12]})
    db.shop.insert({&quot;loc&quot;:[50,60]})
    db.shop.insert({&quot;loc&quot;:[90,95]})`
</code></pre>  实现位置查询：<pre><code>两种：(1) `&quot;$near&quot;`:查询距离某个点最近的坐标点
       (2) `&quot;$geoWithin&quot;`：查询某个形状内的点,可以设置范围:
            ① 矩形范围`（$box）`: `{&quot;$box&quot;:[[x1,y1],[x2,y2]]}`
            ② 圆形范围`（$center）`: `{&quot;$center&quot;:[[x,y],r]}`
            ③ 多边形范围`（$polygon）`: `{&quot;$poltgon&quot;:[[x1,y1],[x2,y2],[x3,y3]....]}`
       (3) 使用`runCommand()`实现信息查询
 例1：假设现在坐标:[11,11]   
     `db.shop.find({&quot;loc&quot;:{&quot;$near&quot;:[11,11]}})`
     注：实际上返回集合内的前100个点
 例2：设置查询距离范围
     `db.shop.find({&quot;loc&quot;:{&quot;$near&quot;:[11,11],&quot;$maxDistance&quot;:5}})`
 例3：查询矩形范围
     `db.shop.find({&quot;loc&quot;:{&quot;$geoWithin&quot;:{&quot;$box&quot;:[[9,9],[12,12]]}}})`
 例4：查询圆形范围
     `db.shop.find({&quot;loc&quot;:{&quot;$geoWithin&quot;:{&quot;$center&quot;:[[11,11],2]}}})`
 例5：查询多边形范围
     `db.shop.find({&quot;loc&quot;:{&quot;$geoWithin&quot;:{&quot;$polygon&quot;:[[4,6],[6,8],[8,9],[5,8]]}}})`
 例6：使用`runCommand()`
     `db.runCommand({&quot;geoNear&quot;:&quot;shop&quot;,&quot;near&quot;:[11,11],&quot;maxDistance&quot;:3,&quot;num&quot;:2})`
</code></pre></li>
</ul>
</li>
<li><p>聚合：统计操作，称为聚合<br>取得集合个数：<code>db.集合.count()</code><br>   注：也可以加条件进行模糊查询，如：<code>db.students.count({&quot;name&quot;:/王/})</code><br>   例：<code>db.shop.count()</code><br>消除重复数据：没有直接的函数支持，只能使用runCommand()函数<br>   语法：<code>db.runCommand({&quot;distinct&quot;:&quot;集合&quot;,&quot;key&quot;:&quot;字段&quot;})</code><br>   例：<code>db.runCommand({&quot;distinct&quot;:&quot;students&quot;,&quot;key&quot;:&quot;name&quot;})</code></p>
<ul>
<li><p>Group操作：使用group操作可以实现数据的分组操作，在MongoDB里面会将集合依据指定的key的不             同进行分组操作，并且每一个组都会产生一个处理的文档结果<br> 例：</p>
<pre><code>`db.runCommand({&quot;group&quot;:{
    &quot;ns&quot; : &quot;students&quot;,
    &quot;key&quot; : {&quot;age&quot;:true},
    &quot;initial&quot; : {&quot;count&quot;:0},
    &quot;condition&quot; : {&quot;age&quot;:{&quot;$gte&quot;:18}},
    &quot;$reduce&quot; : function(doc,prev){
        prev.count++;
        print(&quot;doc=&quot;+doc+&quot; prev=&quot;+prev);
    }
}})`
</code></pre></li>
<li><p>MapReduce：</p>
<p> MapReduce是大数据的精髓所在，实际分为两步处理数据：</p>
<pre><code>Map：将数据分别取出
Reduce：负责数据的最后处理
</code></pre><p> 建立一组雇员数据<br> <code>db.emps.insert({&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:30,&quot;sex&quot;:&quot;男&quot;,&quot;job&quot;:&quot;CLERK&quot;,&quot;salary&quot;:1000})
 db.emps.insert({&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:28,&quot;sex&quot;:&quot;女&quot;,&quot;job&quot;:&quot;MANAGER&quot;,&quot;salary&quot;:4000})
 db.emps.insert({&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:31,&quot;sex&quot;:&quot;男&quot;,&quot;job&quot;:&quot;CLERK&quot;,&quot;salary&quot;:1500})
 db.emps.insert({&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:33,&quot;sex&quot;:&quot;女&quot;,&quot;job&quot;:&quot;MANAGER&quot;,&quot;salary&quot;:5000})
 db.emps.insert({&quot;name&quot;:&quot;孙七&quot;,&quot;age&quot;:27,&quot;sex&quot;:&quot;男&quot;,&quot;job&quot;:&quot;CLERK&quot;,&quot;salary&quot;:1000})
 db.emps.insert({&quot;name&quot;:&quot;王八&quot;,&quot;age&quot;:35,&quot;sex&quot;:&quot;男&quot;,&quot;job&quot;:&quot;PRESIDENT&quot;,&quot;salary&quot;:7000})</code></p>
<p> 使用MapReduce操作最终会将处理结果保存在一个单独的集合里，最终处理效果如下：<br> 例1：按照值为分组，取得每个职位的人名</p>
<pre><code>● 编写分组的定义
    `var jobMapFun = function(){
        emit(this.job,this.name); //按照job分组，取出name
    };`
    经过上述函数操作后结果如下：
        第一组：`{&quot;key&quot;:&quot;CLERK&quot;,&quot;values&quot;:[姓名1,姓名2...]}`
● 编写Reduce操作
    `var jobReduceFun = function(key,values){
        return {&quot;job&quot;:key,&quot;names&quot;:values};
    };`
● 针对MapReduce处理完成的数据进行处理
    `var jobFinalizeFun = function(key,values){
        if(key==&quot;PRESIDENT&quot;){
            return {&quot;job&quot;:key,&quot;names&quot;:values,&quot;info&quot;:&quot;公司老大&quot;}
        }
        return {&quot;job&quot;:key,&quot;names&quot;:values};
    }`
● 进行操作的整合
    第一种
        `db.runCommand({
            &quot;mapreduce&quot;:&quot;emps&quot;,
            &quot;map&quot;:jobMapFun,
            &quot;reduce&quot;:jobReduceFun,
            &quot;out&quot;:&quot;t_job_emp&quot;
        })`
    第二种
        `db.runCommand({
            &quot;mapreduce&quot;:&quot;emps&quot;,
            &quot;map&quot;:jobMapFun,
            &quot;reduce&quot;:jobReduceFun,
            &quot;out&quot;:&quot;t_job_emp&quot;,
            &quot;finalize&quot;: jobFinalizeFun
        })`
</code></pre><p> 例2：统计出各性别的人数，总工资，平均工资，最高工资，最低工资，雇员姓名</p>
<pre><code>●  编写Map
    `var sexMapFun = function(){
        //定义好分组条件，以及取出每个集合要取出的内容
        emit(this.sex,{&quot;ccount&quot;:1,&quot;csal&quot;:this.salary,&quot;cmax&quot;:this.salary,&quot;cmin&quot;:this.salary,&quot;cname&quot;:this.name})
    };`
● 编写Reduce操作
    `var sexReduceFun = function(key,values){
        var total = 0;//统计人数
        var sum = 0;//统计宗工资
        var max = values[0].cmax;
        var min = values[0].cmin;
        var name = new Array()
        for(var x in values){//循环取出values中的内容
            total += values[x].ccount;// 人数增加
            sum += values[x].csal;
            if(max &lt; values[x].cmax){
                max = values[x].cmax;
            }    
            if(min &gt; values[x].cmin){
                min = values[x].cmin;
            }
            name[x] = values[x].cname;
        }
        var avg = (sum/total).toFixed(2);//平均工资，保留两位小数
        //返回数据的处理结果
        return {&quot;count&quot;:total,&quot;avg&quot;:avg,&quot;sum&quot;:sum,&quot;max&quot;:max,&quot;min&quot;:min,&quot;name&quot;:name}
    };`
● 进行操作的整合
    `db.runCommand({
        &quot;mapreduce&quot;:&quot;emps&quot;,
        &quot;map&quot;:sexMapFun,
        &quot;reduce&quot;:sexReduceFun,
        &quot;out&quot;:&quot;t_sex_emp&quot;
    })`
</code></pre><p>聚合框架：虽然MapReduce功能强大，但是复杂度也大，所以MongoDB从2.x开始引入了聚合函数:aggregate</p>
<pre><code>注：在聚合框架里面使用每行的数据引用：&quot;$字段名称&quot;
</code></pre><p> <code>$group</code> : 分组操作，是无序操作，并且在内存中完成的，所以不肯能支持大数据量<br> 例1：实现聚合查询功能—-求出每个职位的雇员人数</p>
<pre><code>`db.emps.aggregate({&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;job_count&quot;:{&quot;$sum&quot;:1}}})`
</code></pre><p> 例2：求出每个职位的总工资</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;job_count&quot;:{&quot;$sum&quot;:&quot;$salary&quot;}}}])`
</code></pre><p> 例3：计算每个职位的平均工资</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;job_count&quot;:{&quot;$sum&quot;:1},&quot;job_avg&quot;:{&quot;$avg&quot;:&quot;$salary&quot;}}}])`
</code></pre><p> 例3：计算每个职位的最高、最低工资</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;max_sal&quot;:{&quot;$max&quot;:&quot;$salary&quot;},&quot;min_sal&quot;:{&quot;$min&quot;:&quot;$salary&quot;}}}])`
</code></pre><p> 例4：求出每个职位的工资数据(数组显示)</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;sal_data&quot;:{&quot;$push&quot;:&quot;$salary&quot;}}}])`
</code></pre><p> 例5：求出每个职位的人员</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;sal_data&quot;:{&quot;$push&quot;:&quot;$name&quot;}}}])`
</code></pre><p> 例5：求出每个职位的人员(去除重复数据)</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;sal_data&quot;:{&quot;$addToSet&quot;:&quot;$name&quot;}}}])`
</code></pre><p> 例6：取出第一个雇员</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;sal_data&quot;:{&quot;$first&quot;:&quot;$name&quot;}}}])`
</code></pre><p> 例7：取出最后一个雇员</p>
<pre><code>`db.emps.aggregate([{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;sal_data&quot;:{&quot;$last&quot;:&quot;$name&quot;}}}])`
</code></pre><p> <code>$project</code>:来控制数据列的显示规则，可执行的规则为如下：</p>
<pre><code>● 普通列 `（{成员 : 1|true}）`: 表示要显示的内容
● `_id列` `（{&quot;_id&quot;:0|false}）`: 表示`“_id”`列是否显示
● 条件过滤列`（{成员 : 表达式}）`：满足表达式后的数据可以进行显示
注：①只有设置的列才可以进行显示，其他列则不显示，实际上这就是数据库的投影机制
    ②四则运算：加法`（“$and”）`、减法`（“$subtract”）`、乘法`（“$mutilply”`）、除法`（“$divide”）`
    ③关系运算：大小比较`（“$cmp”）`，等于`（“$eq”）`，大于`（“$gt”）`，大于等于`（“$gte”）`，
               小于`（“$lt”）`，小于等于`（“$lte”）`，不等于`（“$ne”）`，判断NULL`（“$ifNull”）`
    ④逻辑运算：与（`$and`），或`（“$or）`，非`（“$not”）`
    ⑤字符串操作：连接`（“$concat”）`，截取`（“$substr”）`，转小写`（“$toLower”）`，转大写`（“$toUpper”）`
                 大小写比较`（“$strcasecmp”）`
例1：只显示name、job列，不显示_id、salary列
`db.emps.aggregate({&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1}})  `
例2：计算雇员年薪
`db.emps.aggregate([{&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;job&quot;:1,&quot;salary&quot;:{&quot;年薪&quot;:{&quot;$multiply&quot;:[&quot;$salary&quot;,12]}}}}])`
例3：找出所有工资大于等于2000的雇员姓名、年龄、工资
`db.emps.aggregate([{&quot;$project&quot;:{
    &quot;_id&quot;:0,
    &quot;name&quot;:1,
    &quot;age&quot;:1,
    &quot;工资&quot;:&quot;$salary&quot;,
    &quot;salary&quot;:{&quot;$gte&quot;:[&quot;$salary&quot;,2000]}
}}])`
</code></pre><p> 例4：查找职位是MANAGER的雇员信息<br> `db.emps.aggregate([{“$project”:{</p>
<pre><code>&quot;_id&quot;:0,
&quot;name&quot;:1,
&quot;age&quot;:1,
&quot;职位&quot;:&quot;$job&quot;,
&quot;job&quot;:{&quot;$eq&quot;:[&quot;$job&quot;,&quot;MANAGER&quot;]}
</code></pre><p> }}])<br> db.emps.aggregate([{“$project”:{</p>
<pre><code>&quot;_id&quot;:0,
&quot;name&quot;:1,
&quot;age&quot;:1,
&quot;职位&quot;:&quot;$job&quot;,
&quot;job&quot;:{&quot;$eq&quot;:[&quot;$job&quot;,{&quot;$toUpper&quot;:&quot;manager&quot;}]}
</code></pre><p> }}])<br> db.emps.aggregate([{“$project”:{</p>
<pre><code>&quot;_id&quot;:0,
&quot;name&quot;:1,
&quot;age&quot;:1,
&quot;职位&quot;:&quot;$job&quot;,
&quot;job&quot;:{&quot;$strcasecmp&quot;:[&quot;$job&quot;,&quot;manager&quot;]}
</code></pre><p> }}])`</p>
<p> 例5：查询职位信息的前三位</p>
<p> `db.emps.aggregate([{“$project”:{</p>
<pre><code>&quot;_id&quot;:0,
&quot;name&quot;:1,
&quot;age&quot;:1,
&quot;职位&quot;:&quot;$job&quot;,
&quot;job&quot;:{&quot;$substr&quot;:[&quot;$job&quot;,0,3]}
</code></pre><p> }}])`</p>
<p> <code>$match</code>：用于过滤数据，只输出符合条件的文档。</p>
<pre><code>例：查询工资大于的2000小于8000 的雇员信息
    `db.emps.aggregate([{&quot;$match&quot;:{&quot;salary&quot;:{&quot;$gte&quot;:2000,&quot;$lte&quot;:8000}}}])`
</code></pre><p> 例2：进行管道操作，将$match得到的文档送入$group操作</p>
<pre><code>`db.emps.aggregate([{&quot;$match&quot;:{&quot;salary&quot;:{&quot;$gte&quot;:2000,&quot;$lte&quot;:8000}}},{&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;age&quot;:1,&quot;salary&quot;:1}}])`
</code></pre><p> 总结：<code>$project</code>相当于SELECT字句</p>
<pre><code>`$match`相当于WHERE字句
`$group`相当于GROUP BY操作
</code></pre><p> <code>$sort</code>：实现排序操作，1表示升序，-1表示降序</p>
<pre><code>例1：按照工资进行升序排序查询
    `db.emps.aggregate([{&quot;$sort&quot;:{&quot;salary&quot;:1}}])`
例2：将所有操作一起使用
    `db.emps.aggregate([{&quot;$match&quot;:{&quot;salary&quot;:{&quot;$gte&quot;:1000,&quot;$lte&quot;:10000}}},{&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;salary&quot;:1,&quot;job&quot;:1}},{&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;count&quot;:{&quot;$sum&quot;:1},&quot;avg&quot;:{&quot;$avg&quot;:&quot;$salary&quot;}}},{&quot;$sort&quot;:{&quot;count&quot;:-1}}])`
</code></pre><p> 分页处理：<code>$limit</code>:负责数据的取出个数</p>
<pre><code>      `$skip`:数据的跨过个数
例1：查询3条
`    db.emps.aggregate([{&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;age&quot;:1,&quot;salary&quot;:1}},{&quot;$limit&quot;:3}])`
例2：跨过3条，取出4条
`    db.emps.aggregate([{&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;age&quot;:1,&quot;salary&quot;:1}},{&quot;$skip&quot;:3},{&quot;$limit&quot;:4}])`
例3：综合运用
    `db.emps.aggregate([
        {&quot;$match&quot;:
            {&quot;salary&quot;:{&quot;$gte&quot;:1000,&quot;$lte&quot;:10000}}},
        {&quot;$project&quot;:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;salary&quot;:1,&quot;job&quot;:1}},
        {&quot;$group&quot;:{&quot;_id&quot;:&quot;$job&quot;,&quot;count&quot;:{&quot;$sum&quot;:1},&quot;avg&quot;:{&quot;$avg&quot;:&quot;$salary&quot;}}},
        {&quot;$sort&quot;:{&quot;count&quot;:-1}},
        {&quot;$skip&quot;:1},
        {&quot;$limit&quot;:1}
    ])`
</code></pre><p> <code>$unwind</code>：在查询数据的时候经常会返回数组信息，但是数组不方便信息的浏览，所以提供不<code>“$unwind”</code>的方式可           以将数组变为独立的字符串</p>
<pre><code>注：将数据的数据变为了单行的数据
创建depts集合
`db.depts.insert({&quot;dep&quot;:&quot;技术部&quot;,&quot;bus&quot;:[&quot;研发&quot;,&quot;生产&quot;,&quot;培训&quot;]})`
`db.depts.insert({&quot;dep&quot;:&quot;财务部&quot;,&quot;bus&quot;:[&quot;工资&quot;,&quot;税收&quot;]})`
例：将信息进行转化
    `db.depts.aggregate([
    {&quot;$project&quot;:{&quot;_id&quot;:0,&quot;dep&quot;:true,&quot;bus&quot;:true}},
    {&quot;$unwind&quot;:&quot;$bus&quot;}])`
</code></pre></li>
</ul>
</li>
</ol>
<pre><code>`$geoNear`：可以得到附近的坐标点
    准备测试数据：
        `db.shop.drop()
        db.shop.insert({&quot;loc&quot;:[10,10]})
        db.shop.insert({&quot;loc&quot;:[11,10]})
        db.shop.insert({&quot;loc&quot;:[11,11]})
        db.shop.insert({&quot;loc&quot;:[13,12]})
        db.shop.insert({&quot;loc&quot;:[50,60]})
        db.shop.insert({&quot;loc&quot;:[90,95]})`
    例：查找点[11,12]附近的两个点
        `db.shop.aggregate([
            {&quot;$geoNear&quot;:{
                &quot;near&quot;:[11,11],
                &quot;distanceField&quot;:&quot;loc&quot;,
                &quot;maxDistance&quot;:1,
                &quot;num&quot;:2,
                &quot;spherical&quot;:true
            }}
        ])`

`$out`：利用此操作可以将查询结果输出到到指定的集合里面
例：将投影信息输出到集合emp_out
`db.emps.aggregate([
    {&quot;$project&quot;:{
        &quot;_id&quot;:0,
        &quot;name&quot;:1,
        &quot;age&quot;:1}},
    {&quot;$out&quot;:&quot;emp_out&quot;}
])`
</code></pre><ol>
<li><p>深入操作</p>
<ul>
<li>固定集合：规定集合大小，如果要保存的内容长度超过了集合的长度，那么会采用LRU算法（最近最少使用原则）<pre><code>将最早的的数据移除，从而保存新的数据
</code></pre> 创建固定集合：<pre><code>`db.createCollection(&quot;collName&quot;,{&quot;capped&quot;:true,&quot;size&quot;:1024,&quot;max&quot;:5}) `            
    &quot;capped&quot;：表示一个固定集合
    &quot;size&quot;：表示集合所占的空间大小
    &quot;max&quot;：表示最多能有几条记录
</code></pre> 例：`db.createCollection(“users”,{“capped”:true,”size”:1024,”max”:5}) <pre><code>db.users.insert({&quot;name&quot;:&quot;A&quot;,&quot;age&quot;:12})
db.users.insert({&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:34})
db.users.insert({&quot;name&quot;:&quot;C&quot;,&quot;age&quot;:64})
db.users.insert({&quot;name&quot;:&quot;D&quot;,&quot;age&quot;:43})
db.users.insert({&quot;name&quot;:&quot;E&quot;,&quot;age&quot;:53})`
此时已经达到了集合的上限，那么会继续保存新的内容
`db.users.insert({&quot;name&quot;:&quot;F&quot;,&quot;age&quot;:24})
db.users.insert({&quot;name&quot;:&quot;G&quot;,&quot;age&quot;:66})`
最近最少使用的数据会消失，新数据则会保存，这种操作和缓存机制是非常相似度的
</code></pre></li>
<li><p>GridFS：在MongoDB里面支持大数据的存储（如图片、视频、音乐等二进制数据文件），在CMD使用“mongofiles”命令          来完成<br> （1）利用命令进入文件所在的路径下<br> （2）将文件保存到数据库里</p>
<pre><code>`    mongofiles --port=27017 put 文件名   //保存数据到fs.files集合中`
</code></pre><p> 注：在MongoDB里面有一个fs.files系统集合，这个集合默认保存在test数据库里面，</p>
<p> （3）查看保存的文件</p>
<pre><code>`mongofiles --port=27017 list`
</code></pre><p> （4）查看保存的信息</p>
<pre><code>`use test
db.fs.files.find()`
</code></pre><p> （5）删除文件</p>
<pre><code>mongofiles --port=27017 delete 文件名 
</code></pre></li>
</ul>
</li>
</ol>
<h2 id="三、用户管理-：（针对数据库）"><a href="#三、用户管理-：（针对数据库）" class="headerlink" title="三、用户管理 ：（针对数据库）"></a>三、用户管理 ：（针对数据库）</h2><ul>
<li><p>创建用户 ：<br><code>db.createUser({
  &quot;user&quot;:&quot;root&quot;,
  &quot;pwd&quot;:&quot;123456&quot;,
  &quot;roles&quot;:[{&quot;role&quot;:&quot;readWrite&quot;,&quot;db&quot;:&quot;zyx&quot;}]
})</code></p>
</li>
<li><p>修改密码 ：<br>  db.changeUserPassword(“用户名”,”新密码”)<br>  注：要在不需要授权验证的情况下修改(noauth=true)</p>
</li>
</ul>
<h2 id="四、使用Java操作MongoDB"><a href="#四、使用Java操作MongoDB" class="headerlink" title="四、使用Java操作MongoDB"></a>四、使用Java操作MongoDB</h2><p>（1）基于Mongo-Java-2.x<br>    连接数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 连接数据库</div><div class="line"> */</div><div class="line">public class MongoDemo_conn &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		MongoClient client=new MongoClient(&quot;localhost&quot;,27017);</div><div class="line">		DB db = client.getDB(&quot;zyx&quot;);//连接数据库</div><div class="line">		//进行数据库的用户名和密码的验证</div><div class="line">		boolean authenticate = db.authenticate(&quot;root&quot;, &quot;123456&quot;.toCharArray());</div><div class="line">		if(authenticate)&#123;</div><div class="line">			Set&lt;String&gt; names = db.getCollectionNames();</div><div class="line">			for (String name : names) &#123;</div><div class="line">				System.out.println(&quot;集合名称:&quot;+name);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		client.close();//关闭数据库连接</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基于Mongo-Java-2.x</div><div class="line"> */</div><div class="line">public class TestMongoDB &#123;</div><div class="line"></div><div class="line">	private MongoClient client=null;</div><div class="line">	private DB db=null; </div><div class="line">	private boolean authenticate=false;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void testDelete()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			BasicDBObject cond=new  BasicDBObject();//准备删除 的过滤条件</div><div class="line">			cond.put(&quot;deptno&quot;, new BasicDBObject(&quot;$gte&quot;,1020).append(&quot;$lte&quot;, 1050));</div><div class="line">			WriteResult remove = dept.remove(cond);</div><div class="line">			System.out.println(remove);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 更新多条</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testUdpateMore()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			</div><div class="line">			BasicDBObject condA=new BasicDBObject();//准备要设置的过滤条件</div><div class="line">			condA.put(&quot;deptno&quot;, new BasicDBObject(&quot;$gte&quot;,1020).append(&quot;$lte&quot;, 1050));</div><div class="line">			</div><div class="line">			BasicDBObject condB=new BasicDBObject();//修改器的设置</div><div class="line">			condB.put(&quot;$set&quot;, new BasicDBObject(&quot;dname&quot;,&quot;修改后的&quot;));</div><div class="line">			</div><div class="line">			WriteResult result = dept.updateMulti(condA, condB);</div><div class="line">			System.out.println(result.getN());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 更新一条</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testUdpateOne()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			</div><div class="line">			BasicDBObject condA=new BasicDBObject();//准备要设置的过滤条件</div><div class="line">			condA.put(&quot;deptno&quot;, 1000);</div><div class="line">			</div><div class="line">			BasicDBObject condB=new BasicDBObject();//修改器的设置</div><div class="line">			condB.put(&quot;$set&quot;, new BasicDBObject(&quot;dname&quot;,&quot;修改后的&quot;));</div><div class="line">			</div><div class="line">			WriteResult result = dept.update(condA, condB);</div><div class="line">			System.out.println(result);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 模糊查询</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testFuzzyQuery()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			BasicDBObject cond=new BasicDBObject();//准备设置查询过滤条件</div><div class="line">			Pattern pattern=Pattern.compile(&quot;5&quot;); </div><div class="line">			cond.put(&quot;dname&quot;, new BasicDBObject(&quot;$regex&quot;,pattern));</div><div class="line">			</div><div class="line">			DBCursor cursor=dept.find(cond);//得到全部数据</div><div class="line">			while(cursor.hasNext())&#123;</div><div class="line">				DBObject doc = cursor.next();//得到每一行数据</div><div class="line">				System.out.println(&quot;部门编号:&quot;+doc.get(&quot;deptno&quot;)+&quot; , 部门名称:&quot;+doc.get(&quot;dname&quot;)+&quot; , 部门地点:&quot;+doc.get(&quot;loc&quot;));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 设置范围查询---in</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testRangeQuery()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			BasicDBObject cond=new BasicDBObject();//准备设置查询过滤条件</div><div class="line">			</div><div class="line">			cond.put(&quot;deptno&quot;, new BasicDBObject(&quot;$in&quot;,new int[]&#123;1021,1053,1029&#125;));</div><div class="line">			</div><div class="line">			DBCursor cursor=dept.find(cond);//得到全部数据</div><div class="line">			while(cursor.hasNext())&#123;</div><div class="line">				DBObject doc = cursor.next();//得到每一行数据</div><div class="line">				System.out.println(&quot;部门编号:&quot;+doc.get(&quot;deptno&quot;)+&quot; , 部门名称:&quot;+doc.get(&quot;dname&quot;)+&quot; , 部门地点:&quot;+doc.get(&quot;loc&quot;));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 带条件查询</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testQueryWithCond()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			BasicDBObject cond=new BasicDBObject();//准备设置查询过滤条件</div><div class="line">			//设置查询条件  deptno在1020到1050范围内</div><div class="line">			cond.put(&quot;deptno&quot;, new BasicDBObject(&quot;$gte&quot;,1020).append(&quot;$lte&quot;, 1050));</div><div class="line">			</div><div class="line">			DBCursor cursor=dept.find(cond);//得到全部数据</div><div class="line">			while(cursor.hasNext())&#123;</div><div class="line">				DBObject doc = cursor.next();//得到每一行数据</div><div class="line">				System.out.println(&quot;部门编号:&quot;+doc.get(&quot;deptno&quot;)+&quot; , 部门名称:&quot;+doc.get(&quot;dname&quot;)+&quot; , 部门地点:&quot;+doc.get(&quot;loc&quot;));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 分页查询</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testPage()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			DBCursor cursor=dept.find().skip(0).limit(20);//分页处理</div><div class="line">			while(cursor.hasNext())&#123;</div><div class="line">				DBObject doc = cursor.next();//得到每一行数据</div><div class="line">				System.out.println(&quot;部门编号:&quot;+doc.get(&quot;deptno&quot;)+&quot; , 部门名称:&quot;+doc.get(&quot;dname&quot;)+&quot; , 部门地点:&quot;+doc.get(&quot;loc&quot;));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 读取数据</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testRead()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			DBCursor cursor=dept.find();//得到全部数据</div><div class="line">			while(cursor.hasNext())&#123;</div><div class="line">				DBObject doc = cursor.next();//得到每一行数据</div><div class="line">				System.out.println(&quot;部门编号:&quot;+doc.get(&quot;deptno&quot;)+&quot; , 部门名称:&quot;+doc.get(&quot;dname&quot;)+&quot; , 部门地点:&quot;+doc.get(&quot;loc&quot;));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 插入数据</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testInsert()&#123;</div><div class="line">		if(authenticate)&#123;</div><div class="line">			DBCollection dept = db.getCollection(&quot;deptcol&quot;);</div><div class="line">			for(int x=0;x&lt;1000;x++)&#123;</div><div class="line">				BasicDBObject doc=new BasicDBObject();</div><div class="line">				doc.append(&quot;deptno&quot;, 1000+x);</div><div class="line">				doc.append(&quot;dname&quot;, &quot;技术部-&quot;+x);</div><div class="line">				doc.append(&quot;loc&quot;, &quot;临潼-&quot;+x);</div><div class="line">				dept.insert(doc);//保存数据</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Before</div><div class="line">	public void connection() throws Exception&#123;</div><div class="line">		client=new MongoClient(&quot;localhost&quot;,27017);</div><div class="line">		db = client.getDB(&quot;zyx&quot;);//连接数据库</div><div class="line">		//进行数据库的用户名和密码的验证</div><div class="line">		authenticate = db.authenticate(&quot;root&quot;, &quot;123456&quot;.toCharArray());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@After</div><div class="line">	public void close()&#123;</div><div class="line">		client.close();//关闭数据库连接</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）基于Mongo-Java-3.x<br>    连接数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MongoDB_conn &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MongoClientURI uri=new MongoClientURI(&quot;mongodb://root:123456@localhost:27017/zyx&quot;);</div><div class="line">		MongoClient client=new MongoClient(uri);</div><div class="line">		MongoDatabase database = client.getDatabase(&quot;zyx&quot;);</div><div class="line">		client.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>（3）测试代码
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line">public class TestMongoDB &#123;</div><div class="line"></div><div class="line">	private MongoClientURI uri=null;</div><div class="line">	private MongoClient client=null;</div><div class="line">	private MongoDatabase database =null;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *统计查询,根据job分组，统计平均工资</div><div class="line">	 *</div><div class="line">	 *	db.emps.aggregate([</div><div class="line">	 *		&#123;&quot;$group&quot;:&#123;</div><div class="line">	 *					&quot;_id&quot;:&quot;$job&quot;,</div><div class="line">	 *					&quot;job_count&quot;:&#123;&quot;$sum&quot;:1&#125;,</div><div class="line">	 *					&quot;job_avg&quot;:&#123;&quot;$avg&quot;:&quot;$salary&quot;&#125;</div><div class="line">	 *				&#125;</div><div class="line">	 *		&#125;</div><div class="line">	 *	])</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testAggregate()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; emps = database.getCollection(&quot;emps&quot;);</div><div class="line">		List&lt;BasicDBObject&gt; list=new ArrayList&lt;BasicDBObject&gt;();</div><div class="line">		BasicDBObject cond=new BasicDBObject(&quot;$group&quot;,new BasicDBObject(&quot;_id&quot;,&quot;$job&quot;).append(&quot;job_count&quot;, new BasicDBObject(&quot;$sum&quot;,1)).append(&quot;job_avg&quot;, new BasicDBObject(&quot;$avg&quot;,&quot;$salary&quot;)));</div><div class="line">		list.add(cond);</div><div class="line">		MongoCursor&lt;Document&gt; cursor = emps.aggregate(list).iterator();</div><div class="line">		while (cursor.hasNext()) &#123;</div><div class="line">			Document doc = (Document) cursor.next();</div><div class="line">			System.out.println(&quot;职位:&quot;+doc.getString(&quot;_id&quot;)+&quot;,人数:&quot;+doc.getInteger(&quot;job_count&quot;)+&quot;,平均工资:&quot;+doc.getDouble(&quot;job_avg&quot;));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *删除数据</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testDelete()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		BasicDBObject cond=new BasicDBObject(&quot;sid&quot;,0);//删除条件</div><div class="line">		DeleteResult result = student.deleteOne(cond);</div><div class="line">		System.out.println(result);</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *更新操作</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testUpdate()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		BasicDBObject condA=new BasicDBObject(&quot;sid&quot;,0);//查询条件</div><div class="line">		BasicDBObject condB=new BasicDBObject(&quot;$set&quot;,new BasicDBObject(&quot;sname&quot;,&quot;zyx&quot;));</div><div class="line">		UpdateResult result = student.updateOne(condA, condB);</div><div class="line">		System.out.println(result);</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *分页查询 </div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testQueryPage()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		BasicDBObject cond=new BasicDBObject();</div><div class="line">		Pattern pattern=Pattern.compile(&quot;5&quot;);</div><div class="line">		cond.put(&quot;sname&quot;, new BasicDBObject(&quot;$regex&quot;,pattern).append(&quot;$options&quot;, &quot;i&quot;));</div><div class="line">		</div><div class="line">		MongoCursor&lt;Document&gt; cursor = student.find(cond).skip(5).limit(5).iterator();</div><div class="line">		while (cursor.hasNext()) &#123;</div><div class="line">			Document doc = (Document) cursor.next();</div><div class="line">			System.out.println(&quot;学号:&quot;+doc.get(&quot;sid&quot;)+&quot;,姓名:&quot;+doc.get(&quot;sname&quot;)+&quot;,性别:&quot;+doc.get(&quot;sex&quot;));</div><div class="line">			//System.out.println(doc);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *模糊查询 </div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testFuzzyQuery()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		BasicDBObject cond=new BasicDBObject();</div><div class="line">		Pattern pattern=Pattern.compile(&quot;5&quot;);</div><div class="line">		cond.put(&quot;sname&quot;, new BasicDBObject(&quot;$regex&quot;,pattern).append(&quot;$options&quot;, &quot;i&quot;));</div><div class="line">		</div><div class="line">		MongoCursor&lt;Document&gt; cursor = student.find(cond).iterator();</div><div class="line">		while (cursor.hasNext()) &#123;</div><div class="line">			Document doc = (Document) cursor.next();</div><div class="line">			System.out.println(&quot;学号:&quot;+doc.get(&quot;sid&quot;)+&quot;,姓名:&quot;+doc.get(&quot;sname&quot;)+&quot;,性别:&quot;+doc.get(&quot;sex&quot;));</div><div class="line">			//System.out.println(doc);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *范围查询 </div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testRangeQuery()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		BasicDBObject cond=new BasicDBObject();</div><div class="line">		cond.put(&quot;sid&quot;, new BasicDBObject(&quot;$gt&quot;,10).append(&quot;$lt&quot;, 30));</div><div class="line">		</div><div class="line">		MongoCursor&lt;Document&gt; cursor = student.find(cond).iterator();</div><div class="line">		while (cursor.hasNext()) &#123;</div><div class="line">			Document doc = (Document) cursor.next();</div><div class="line">			System.out.println(&quot;学号:&quot;+doc.get(&quot;sid&quot;)+&quot;,姓名:&quot;+doc.get(&quot;sname&quot;)+&quot;,性别:&quot;+doc.get(&quot;sex&quot;));</div><div class="line">			//System.out.println(doc);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 *数据查询 </div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testQuery()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		MongoCursor&lt;Document&gt; cursor = student.find().iterator();</div><div class="line">		while (cursor.hasNext()) &#123;</div><div class="line">			Document doc = (Document) cursor.next();</div><div class="line">			System.out.println(&quot;学号:&quot;+doc.get(&quot;sid&quot;)+&quot;,姓名:&quot;+doc.get(&quot;sname&quot;)+&quot;,性别:&quot;+doc.get(&quot;sex&quot;));</div><div class="line">			//System.out.println(doc);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/*</div><div class="line">	 * 数据插入</div><div class="line">	 */</div><div class="line">	@Test</div><div class="line">	public void testInsert()&#123;</div><div class="line">		MongoCollection&lt;Document&gt; student = database.getCollection(&quot;student&quot;);</div><div class="line">		</div><div class="line">		List&lt;Document&gt; documents=new ArrayList&lt;Document&gt;(); </div><div class="line">		for(int x=0;x&lt;100;x++)&#123;</div><div class="line">			Document doc=new Document();</div><div class="line">			doc.put(&quot;sid&quot;, x);</div><div class="line">			doc.put(&quot;sname&quot;, &quot;姓名-&quot;+x);</div><div class="line">			doc.put(&quot;sex&quot;, x%2==0?&quot;男&quot;:&quot;女&quot;);</div><div class="line">			documents.add(doc);</div><div class="line">		&#125;</div><div class="line">		student.insertMany(documents);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Before</div><div class="line">	public void connection() throws Exception&#123;</div><div class="line">		uri=new MongoClientURI(&quot;mongodb://root:123456@localhost:27017/zyx&quot;);</div><div class="line">		client=new MongoClient(uri);</div><div class="line">		database = client.getDatabase(&quot;zyx&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@After</div><div class="line">	public void close()&#123;</div><div class="line">		client.close();//关闭数据库连接</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、操作数据库&quot;&gt;&lt;a href=&quot;#一、操作数据库&quot; class=&quot;headerlink&quot; title=&quot;一、操作数据库&quot;&gt;&lt;/a&gt;一、操作数据库&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建和切换数据库 ：&lt;code&gt;use dbName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.joahcy.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.joahcy.com/tags/MongoDB/"/>
    
  </entry>
  
</feed>
